<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ankang</title>
  <icon>https://www.gravatar.com/avatar/c4114f39e729347bafc2f1759865816e</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ankang.icu/"/>
  <updated>2021-05-17T11:29:02.178Z</updated>
  <id>http://ankang.icu/</id>
  
  <author>
    <name>ankang</name>
    <email>ankangz98@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NodeJS相关/Web服务器</title>
    <link href="http://ankang.icu/2021/05/17/NodeJS%E7%9B%B8%E5%85%B3-Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://ankang.icu/2021/05/17/NodeJS相关-Web服务器/</id>
    <published>2021-05-17T11:24:59.000Z</published>
    <updated>2021-05-17T11:29:02.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p>事件驱动异步I/O单进程的服务端JS环境，具有事件循环。浏览器是JS的前端运行环境；Node JS是JS的后端运行环境，在后端中运行无法调用DOM和BOM等浏览器内置API。</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>NodeJs基于Commonjs模块化开发的规范</p><p>导出：exports/module.exports</p><ul><li>共同点：导出模块</li><li>不同点：module.exports它可以导出对象，而exports不可以</li><li>exports = module.exports 引用 本质：原型指向</li></ul><p>导入：require(路径)</p><a id="more"></a><h5 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h5><h6 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入一个内置的模块</span></span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">"os"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(os.hostname);</span><br><span class="line"><span class="comment">//操作系统平台</span></span><br><span class="line">clg(os.platform());</span><br><span class="line"><span class="comment">//换行符 windoe \r\n linux/mac \n</span></span><br><span class="line"><span class="comment">// os.EOL 一般用于记录日志</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"我是一个"</span> + os.EOL + <span class="string">"标签"</span></span><br><span class="line">clg(str);</span><br><span class="line"><span class="comment">//CPU核数</span></span><br><span class="line">clg(os.cpus().length);</span><br><span class="line"><span class="comment">//总内存大小 字节 =&gt; 字节/1024(kb)=&gt;kb/1024(mb)=&gt;mb/1024(G)</span></span><br><span class="line">clg(os.totalmem()/<span class="number">1024</span>/<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><h6 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h6><p>路径模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">let</span> url = <span class="string">''</span>;</span><br><span class="line"><span class="comment">//得到url和路径中的文件名称--获取最后一个分隔符后的字符串</span></span><br><span class="line">clg(path.basename(url));</span><br><span class="line"><span class="comment">//得到文件所在目录--获取最后一个分隔符之前的字符串</span></span><br><span class="line">clg(path.dirname(url));</span><br><span class="line"><span class="comment">//得到扩展名 带.的扩展名</span></span><br><span class="line">clg(path.extname(url));</span><br><span class="line"><span class="comment">//拼接路径</span></span><br><span class="line"><span class="comment">//全局变量 __dirname 当前执行脚本所在的路径</span></span><br><span class="line"><span class="keyword">const</span> logpath = path.join(__dirname,<span class="string">'data/log.txt'</span>)</span><br><span class="line"><span class="comment">//const logpath = path.join(__dirname,'data','log.txt')</span></span><br><span class="line"><span class="comment">//const logpath = path.join(__dirname,'../data','log.txt')</span></span><br><span class="line"><span class="comment">//相对地址转换为绝对地址</span></span><br><span class="line">clg(path.resolve(<span class="string">'./data'</span>,<span class="string">'log.txt'</span>));</span><br><span class="line"><span class="comment">//clg(path.resolve('../data','log.txt'));</span></span><br></pre></td></tr></table></figure><h6 id="url模块"><a href="#url模块" class="headerlink" title="url模块"></a>url模块</h6><p>分析url地址</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> href = <span class="string">''</span>;</span><br><span class="line"><span class="comment">//参数1：分析url地址</span></span><br><span class="line"><span class="comment">//参数2：boolean true/false query属性是否自动转换为对象</span></span><br><span class="line"><span class="comment">//参数3：boolean 一般不用，没有协议时，自动识别域名。</span></span><br><span class="line">clg(url.parse(href,<span class="literal">true</span>));</span><br></pre></td></tr></table></figure><h6 id="JS中内置类URL"><a href="#JS中内置类URL" class="headerlink" title="JS中内置类URL"></a>JS中内置类URL</h6><p>get/post方法得到的数据是字符串形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*let href = ''</span></span><br><span class="line"><span class="comment">const url = new URL(href);</span></span><br><span class="line"><span class="comment">clg(url.searchParams);</span></span><br><span class="line"><span class="comment">//获取query中相同名称的数据，以数组形式返回</span></span><br><span class="line"><span class="comment">clg(url.searchParams.getAll('id'));</span></span><br><span class="line"><span class="comment">//获取全部的get数据</span></span><br><span class="line"><span class="comment">clg(url.searchParans.entries());</span></span><br><span class="line"><span class="comment">for(let [key,value] of url.searchParans.entries())&#123;</span></span><br><span class="line"><span class="comment">clg(key,value);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> href = <span class="string">'?...'</span></span><br><span class="line"><span class="keyword">const</span> query = <span class="keyword">new</span> URLSearchParams(href)</span><br><span class="line"><span class="comment">//search对象</span></span><br><span class="line">clg(query)</span><br></pre></td></tr></table></figure><h6 id="querystring模块"><a href="#querystring模块" class="headerlink" title="querystring模块"></a>querystring模块</h6><p>用于解析和格式化URL查询字符串的实用工具。</p><h6 id="fs模块"><a href="#fs模块" class="headerlink" title="fs模块"></a>fs模块</h6><p>文件交互相关，buffer：容器（缓冲器）一般用来存储数据流。字符串=&gt;二进制=&gt;字符串（文件操作时转码）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">"你好"</span>;</span><br><span class="line"><span class="comment">//字符串转为buffer流 == 一个中文转为3个字节</span></span><br><span class="line"><span class="comment">//clg(Buffer.from(str));</span></span><br><span class="line"><span class="comment">//创建一个文件</span></span><br><span class="line"><span class="comment">//异步 -- 回调</span></span><br><span class="line"><span class="comment">//回调函数err中的参数，如果返回为null则表示成功，为对象表示写入异常</span></span><br><span class="line">fs.writeFile(path.resolve(<span class="string">'/data/list.txt'</span>),Buffer.from(str),err=&gt;clg(err))</span><br><span class="line"><span class="comment">//同步</span></span><br><span class="line">fs.writeFileSync(path.resolve(<span class="string">'/data/list.txt'</span>),str)</span><br><span class="line"><span class="comment">//文件异步追加</span></span><br><span class="line">fs.appendFile(path.resolve(<span class="string">'/data/list.txt'</span>),Buffer.from(str),err=&gt;clg(err))</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件</span></span><br><span class="line"><span class="comment">//nodejs中回调函数，第一个参数都是错误</span></span><br><span class="line"><span class="comment">/*fs.readFile(filepath,'utf-8',(err,buffer)=&gt;&#123;</span></span><br><span class="line"><span class="comment">    clg(buffer);</span></span><br><span class="line"><span class="comment">&#125;)*/</span></span><br><span class="line">fs.readFile(filepath,(err,buffer)=&gt;&#123;</span><br><span class="line">    clg(buffer.toString());</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//删除文件</span></span><br><span class="line">fs.unlink(newfilepath,err =&gt; clg(err));</span><br><span class="line"><span class="comment">//查看文件信息</span></span><br><span class="line">fs.stat()</span><br><span class="line"><span class="comment">//判断当前文件或目录是否存在</span></span><br><span class="line">clg(fs.existsSync(filepath));</span><br><span class="line"><span class="comment">//创建目录</span></span><br><span class="line"><span class="keyword">const</span> dirpath = path.join(__dirname,<span class="string">'data'</span>,<span class="string">'aa'</span>)</span><br><span class="line">fs.mkdir(dirpath,err =&gt; clg(err))</span><br><span class="line"><span class="comment">//迭代创建</span></span><br><span class="line">fs.mkdir(dirpath,&#123;<span class="attr">recursive</span>:<span class="literal">true</span>&#125;,err =&gt; clg(err));</span><br><span class="line"><span class="comment">//读取目录 返回数组类型</span></span><br><span class="line">fs.readdir(dirpath,<span class="string">'utf-8'</span>,(err,data)=&gt;clg(data));</span><br><span class="line"><span class="comment">//删除 默认只删除空目录</span></span><br><span class="line">fs.rmdir(dirpath,err =&gt; clg(err))</span><br><span class="line"><span class="comment">//递归删除</span></span><br><span class="line">fs.rmdir(dirpath,&#123;<span class="attr">recursive</span>:<span class="literal">true</span>&#125;,err =&gt; clg(err))</span><br><span class="line"><span class="comment">//重命名</span></span><br></pre></td></tr></table></figure><p><img src="/2021/05/17/NodeJS相关-Web服务器/1.png" alt="1"></p><p>数据流：读流（fs.createReadStream）、写流（fs.createWriteStream）</p><blockquote><p>fs.createReadStream(filepath).pipe(fs.createWriteStream(newfilepath))</p></blockquote><h6 id="事件触发器（events）"><a href="#事件触发器（events）" class="headerlink" title="事件触发器（events）"></a>事件触发器（events）</h6><p>对”发布/订阅”模式的实现，加载events模块后，通过EventEmitter属性建立一个实例化对象。通过<code>on</code>方法为事件指定回调函数，最后通过emit方法触发事件。先订阅-后发布</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Event = <span class="built_in">require</span>(<span class="string">'event'</span>).EventEmitter</span><br><span class="line"><span class="keyword">const</span> ev = <span class="keyword">new</span> Event;</span><br><span class="line"><span class="comment">//订阅</span></span><br><span class="line">ev.on(<span class="string">''</span>,(...args)=&gt;clg(args))</span><br><span class="line"><span class="comment">//发布</span></span><br><span class="line">ev.emit(<span class="string">''</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">ev.emit(<span class="string">''</span>,&#123;<span class="attr">key</span>:value&#125;);</span><br></pre></td></tr></table></figure><h5 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h5><p>首先查看当前项目中有没有package.json文件，–<code>npm init -y</code></p><p>npm -S/npm -D:</p><h5 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块?"></a>自定义模块?</h5><p>自定义模块命名为index.js，如果重命名文档，可以采用修改package.json文档内容，将指向改变。导出变量，函数，类，实例化对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"main"</span>: <span class="string">"index.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="npm-参数"><a href="#npm-参数" class="headerlink" title="npm 参数"></a>npm 参数</h5><p>process.argv:获取的是当前输入的所有命令语句块–数组，通过slice截取数组中有效的元素，<code>process.argv.slice(2)</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node(命令) 执行的文件(.js) [自定义参数]</span></span><br><span class="line"><span class="comment">//获取执行命令中的参数</span></span><br><span class="line"><span class="comment">//1、</span></span><br><span class="line"><span class="keyword">let</span> args = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> arr = process.argv.slice(<span class="number">2</span>);</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(item.startsWith(<span class="string">'--'</span>))&#123;</span><br><span class="line">        args[item.slice(<span class="number">2</span>)] = arr[index + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、</span></span><br><span class="line"><span class="keyword">let</span> args = process.argv.slice(<span class="number">2</span>).reduce(<span class="function">(<span class="params">p,c,index,arr</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c.startsWith(<span class="string">'--'</span>))&#123;</span><br><span class="line">        p[c.slice(<span class="number">2</span>)] = arr[index + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;,&#123;&#125;);</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="built_in">console</span>.log(args)</span><br></pre></td></tr></table></figure><h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><p><code>node xx | grep xx</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手动设置环境变量</span></span><br><span class="line">process.env.NODE_ENV = <span class="string">"dev"</span></span><br><span class="line"><span class="comment">//获取指定的环境变量</span></span><br><span class="line"><span class="keyword">if</span>(process.env.NODE_ENV === <span class="string">"dev"</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'开发中'</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(process.env.NODE_ENV = <span class="string">"test"</span>)&#123;</span><br><span class="line">    clg(<span class="string">"测试中"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(process.env.NODE_ENV = <span class="string">"production"</span>)&#123;</span><br><span class="line">    clg(<span class="string">"上线"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    clg(<span class="string">'其他'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="cross-env插件："><a href="#cross-env插件：" class="headerlink" title="cross-env插件："></a>cross-env插件：</h6><p>运行跨平台设置和使用环境变量的脚本</p><p>安装cross-env插件：<code>npm i cross-env -D</code>，在生成的package.json文件中配置。</p><p><img src="/2021/05/17/NodeJS相关-Web服务器/2.png" alt="image-20210517112543161"></p><p><img src="/2021/05/17/NodeJS相关-Web服务器/3.png" alt="image-20210517112657192"></p><h3 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h3><p>端口数量：0-65535</p><p>成为一个http服务器</p><ul><li>主机+协议+端口号</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http事件处理</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="comment">//创建一个web服务器</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line"><span class="comment">//侦听事件 浏览器请求 request</span></span><br><span class="line"><span class="comment">//request 请求对象，用于获取浏览器请求 头和体</span></span><br><span class="line"><span class="comment">//response 服务器对浏览器的响应 行 头 体</span></span><br><span class="line">server.on(<span class="string">'request'</span>,(request,response)=&gt;&#123;</span><br><span class="line">    <span class="comment">//clg("请求了！");</span></span><br><span class="line">    <span class="comment">//当前的请求</span></span><br><span class="line">    clg(request.uri);</span><br><span class="line">    <span class="comment">//获取请求的方法</span></span><br><span class="line">    clg(request.method);</span><br><span class="line">    <span class="comment">//获取请求头--日志</span></span><br><span class="line">    <span class="keyword">if</span>(request.url !== <span class="string">'/favicon.ico'</span>)&#123;</span><br><span class="line">        clg(<span class="keyword">new</span> <span class="built_in">Date</span>().toUTCString());</span><br><span class="line">        clg(request.headers[<span class="string">'user-agent'</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//响应头</span></span><br><span class="line">    response.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'text/html;charset=utf-8'</span>);</span><br><span class="line">    <span class="comment">//服务器给浏览器响应</span></span><br><span class="line">    response.end(<span class="string">"&lt;h3&gt;你好世界&lt;/h3&gt;"</span>)</span><br><span class="line">    response.end(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">'张三'</span>&#125;))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//监听 端口</span></span><br><span class="line"><span class="comment">//0.0.0.0 =&gt; 监听服务器中所有的网址请求</span></span><br><span class="line"><span class="comment">//具体的IP 对应此网卡的IP才可以访问 10 200</span></span><br><span class="line"><span class="comment">//ifconfig =&gt; linux</span></span><br><span class="line">server.listen(<span class="number">3000</span>,<span class="string">'0.0.0.0'</span>,()=&gt;&#123;</span><br><span class="line">    clg(<span class="string">'服务已启动 http://127.0.0.1:3000'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Node-js&quot;&gt;&lt;a href=&quot;#Node-js&quot; class=&quot;headerlink&quot; title=&quot;Node.js&quot;&gt;&lt;/a&gt;Node.js&lt;/h2&gt;&lt;p&gt;事件驱动异步I/O单进程的服务端JS环境，具有事件循环。浏览器是JS的前端运行环境；Node JS是JS的后端运行环境，在后端中运行无法调用DOM和BOM等浏览器内置API。&lt;/p&gt;
&lt;h3 id=&quot;模块化&quot;&gt;&lt;a href=&quot;#模块化&quot; class=&quot;headerlink&quot; title=&quot;模块化&quot;&gt;&lt;/a&gt;模块化&lt;/h3&gt;&lt;p&gt;NodeJs基于Commonjs模块化开发的规范&lt;/p&gt;
&lt;p&gt;导出：exports/module.exports&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共同点：导出模块&lt;/li&gt;
&lt;li&gt;不同点：module.exports它可以导出对象，而exports不可以&lt;/li&gt;
&lt;li&gt;exports = module.exports 引用 本质：原型指向&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;导入：require(路径)&lt;/p&gt;
    
    </summary>
    
    
      <category term="Server" scheme="http://ankang.icu/tags/Server/"/>
    
      <category term="NodeJS" scheme="http://ankang.icu/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>flex布局</title>
    <link href="http://ankang.icu/2021/04/30/flex%E5%B8%83%E5%B1%80/"/>
    <id>http://ankang.icu/2021/04/30/flex布局/</id>
    <published>2021-04-30T00:28:08.000Z</published>
    <updated>2021-04-30T00:30:49.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flex容器：采用 Flex 布局的元素的父元素；</span><br><span class="line">Flex项目：采用 Flex 布局的元素的父元素的子元素；</span><br><span class="line">容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</span><br><span class="line">项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</span><br></pre></td></tr></table></figure><h4 id="flex容器属性"><a href="#flex容器属性" class="headerlink" title="flex容器属性"></a>flex容器属性</h4><p>​    1、display:flex、inline-flex</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。</span><br></pre></td></tr></table></figure><p>​    2、flex-direction属性 决定主轴的方向（即项目的排列方向）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-direction: row | row-reverse | column | column-reverse;</span><br></pre></td></tr></table></figure><p>​    3、flex-wrap属性，定义子元素是否换行显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-wrap: nowrap | wrap | wrap-reverse;</span><br></pre></td></tr></table></figure><p>​    4、 flex-flow </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap;</span><br></pre></td></tr></table></figure><p>​    5、 justify-content属性 定义了项目在主轴（）上的对齐方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around;</span><br></pre></td></tr></table></figure><p>​    6、align-items属性定义项目在交叉轴上如何对齐。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-items: flex-start | flex-end | center | baseline | stretch（默认值）;</span><br></pre></td></tr></table></figure><p>​    7、align-content属性定义了多根轴线的对齐方式。对于单行子元素，该属性不起作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">align-content在侧轴上执行样式的时候，会把默认的间距给合并。对于单行子元素，该属性不起作用</span><br></pre></td></tr></table></figure><h4 id="flex项目属性"><a href="#flex项目属性" class="headerlink" title="flex项目属性"></a>flex项目属性</h4><p>1、order</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">说明：</span><br><span class="line">number排序优先级，数字越大越往后排，默认为0，支持负数。</span><br></pre></td></tr></table></figure><p>2、flex</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">说明：</span><br><span class="line">复合属性。设置或检索弹性盒模型对象的子元素如何分配空间</span><br><span class="line">详细属性值：</span><br><span class="line">缩写「flex: 1」, 则其计算值为「1 1 0%」</span><br><span class="line">缩写「flex: auto」, 则其计算值为「1 1 auto」</span><br><span class="line">flex: none」, 则其计算值为「0 0 auto」</span><br><span class="line">flex: 0 auto」或者「flex: initial」, 则其计算值为「0 1 auto」，即「flex」初始值</span><br></pre></td></tr></table></figure><h3 id="flex布局案例"><a href="#flex布局案例" class="headerlink" title="flex布局案例"></a>flex布局案例</h3><p><img src="/2021/04/30/flex布局/4.png" alt></p><p><a href="https://www.cnblogs.com/sxz2008/p/6635196.html" target="_blank" rel="noopener">相关学习</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Flex布局&quot;&gt;&lt;a href=&quot;#Flex布局&quot; class=&quot;headerlink&quot; title=&quot;Flex布局&quot;&gt;&lt;/a&gt;Flex布局&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
    
      <category term="CSS3" scheme="http://ankang.icu/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript数据类型/类/泛型</title>
    <link href="http://ankang.icu/2021/04/28/TypeScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E7%B1%BB-%E6%B3%9B%E5%9E%8B/"/>
    <id>http://ankang.icu/2021/04/28/TypeScript数据类型-类-泛型/</id>
    <published>2021-04-28T13:49:19.000Z</published>
    <updated>2021-04-28T13:54:17.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>数组、元组、自定义、联合类型；断言；TS编译配置；TS类概念；泛型</p><a id="more"></a><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数字类型的数组</span></span><br><span class="line"><span class="comment">/* var arr: number []</span></span><br><span class="line"><span class="comment">arr=[1,2, 3] */</span></span><br><span class="line"><span class="comment">//字符串数组</span></span><br><span class="line"><span class="comment">/* var arr: string [ ]</span></span><br><span class="line"><span class="comment">arr = ['a', 'b'] */</span></span><br><span class="line"><span class="comment">//泛型定义</span></span><br><span class="line"><span class="comment">// var arr: number[]</span></span><br><span class="line"><span class="keyword">var</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;</span><br><span class="line">    arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// var arr: string []</span></span><br><span class="line"><span class="keyword">var</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line"><span class="comment">//自定义类型</span></span><br><span class="line"><span class="keyword">type</span> userType= &#123; </span><br><span class="line">    id: <span class="built_in">number</span>,</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr: <span class="built_in">Array</span>&lt;userType&gt;</span><br><span class="line">arr=[</span><br><span class="line">    &#123;</span><br><span class="line">        id:<span class="string">'1'</span> ,</span><br><span class="line">        name :<span class="string">'张三'</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h5><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。比如， 你可以定义一对值分别为string和number类型的元组。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义 tuple---数组的另一种表现形式</span></span><br><span class="line"><span class="comment">//定义一个数组,而且指定它的长度和每一项类型</span></span><br><span class="line"><span class="keyword">var</span> arr:[<span class="built_in">number</span>,<span class="built_in">string</span>,<span class="built_in">boolean</span>]</span><br><span class="line">arr=[<span class="number">1</span>,<span class="string">'a'</span>,<span class="literal">true</span>]</span><br><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="comment">//var arr1=[1,2]</span></span><br></pre></td></tr></table></figure><h5 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h5><p>默认类型不满足业务中变量定义，为了更好的后续维护。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> url = <span class="built_in">string</span></span><br><span class="line"><span class="keyword">let</span> httpurl:url</span><br><span class="line">httpurl = <span class="string">'http://xxx.com'</span></span><br><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">    name:<span class="built_in">string</span>,</span><br><span class="line">    age:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> user:User</span><br><span class="line">user = &#123;name: <span class="string">'aa'</span>,age:<span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure><p>定义对象类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> userObjectType = &#123;</span><br><span class="line">    id: <span class="built_in">number</span>,</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> userObj: userObjectType</span><br><span class="line">userObj = &#123;id:<span class="number">1</span>,name:<span class="string">'aaa'</span>&#125;</span><br></pre></td></tr></table></figure><p>定义数组对象类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userArr: userObjectType[]</span><br><span class="line"><span class="keyword">var</span> userArr: <span class="built_in">Array</span>&lt;userObjectType&gt;</span><br><span class="line">    userArr = [</span><br><span class="line">        &#123; id: <span class="number">1</span>, name: <span class="string">'aaa'</span> &#125;</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>限制函数的参数和返回值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> fnType = <span class="function">(<span class="params">id: <span class="built_in">number</span>, name: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> fnType = &#123;</span><br><span class="line">    (id: <span class="built_in">number</span>, name: <span class="built_in">string</span>): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn: fnType = (id: <span class="built_in">number</span>, name: <span class="built_in">string</span>): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'aa'</span></span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>, <span class="string">'aa'</span>)</span><br></pre></td></tr></table></figure><h5 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> userObjectType = &#123;</span><br><span class="line">    <span class="comment">// 联合类型</span></span><br><span class="line">    id: <span class="built_in">number</span> | <span class="built_in">string</span>,</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> userArr: <span class="built_in">Array</span>&lt;userObjectType&gt;</span><br><span class="line">    userArr = [</span><br><span class="line">        &#123; id: <span class="number">1</span>, name: <span class="string">'aaa'</span> &#125;,</span><br><span class="line">        &#123; id: <span class="string">'2'</span>, name: <span class="string">'aaa'</span> &#125;,</span><br><span class="line">    ]</span><br><span class="line"><span class="keyword">var</span> fn = (id: <span class="built_in">number</span> | <span class="built_in">string</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'qqqq'</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>)</span><br><span class="line">fn(<span class="string">'2'</span>)</span><br></pre></td></tr></table></figure><h5 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h5><p>感叹号 <code>！</code>当一个对象null或者undefined时，停止；问号<code>?</code>可以存在可以不存在。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line"><span class="comment">//str = 'aaa';</span></span><br><span class="line"><span class="built_in">console</span>.log((str <span class="keyword">as</span> <span class="built_in">string</span>).length)</span><br><span class="line"><span class="built_in">console</span>.log((&lt;<span class="built_in">string</span>&gt;str).length)</span><br><span class="line"><span class="comment">// dom获取</span></span><br><span class="line"><span class="keyword">var</span> dom: <span class="built_in">any</span> = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line"><span class="comment">// 在实际工作中，有没有可能，dom获取不到，null</span></span><br><span class="line">dom.style.color = <span class="string">'red'</span></span><br></pre></td></tr></table></figure><h3 id="编译配置"><a href="#编译配置" class="headerlink" title="编译配置"></a>编译配置</h3><p><a href="https://www.tslang.cn/docs/handbook/compiler-options.html" target="_blank" rel="noopener">配置文档</a></p><p>tsc编译是可以通过 <code>tsconfig.json</code>来进行自定义配置的—通过 <code>tsc --init</code>命令生成，当然为了实现实时编译可以在当前目录<code>npm init -y</code>生成一个npm命令文件(package.json)，添加一个实时编译命令 <code>npm run dev</code></p><p><img src="/2021/04/28/TypeScript数据类型-类-泛型/img1.png" alt="image-20210428194846907"></p><p><img src="/2021/04/28/TypeScript数据类型-类-泛型/img2.png" alt="image-20210428194919980"></p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>TypeScript 是面向对象的 JavaScript。类描述了所创建的对象共同的属性和方法。TypeScript 支持面向对象的所有特性，比如 类、抽象类、接口等。</p><h5 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h5><p>TS中属性的修饰符有三种：public、protected、private；public：默认值，可以在类、子类和对象中修改；protected：可以在类、子类中修改，受保护的；private：可以在类中修改，私有的。</p><p>成员属性名后加!表示成员属性不为null。</p><p>readonly：只读–针对成员属性，设置后，可以直接定义时赋值或在构造函数中赋值是不会报错的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名 &#123;</span><br><span class="line">    属性名: 类型;</span><br><span class="line">    <span class="comment">//静态属性</span></span><br><span class="line">    <span class="keyword">static</span> 属性名:类型</span><br><span class="line">    <span class="comment">//只读属性：只针对成员属性</span></span><br><span class="line">    readonly 属性名:类型 = 值</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">参数:类型</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.属性名 = 参数;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实例方法</span></span><br><span class="line">    方法名()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Myclass &#123;</span><br><span class="line">    <span class="keyword">public</span> id: <span class="built_in">number</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">id: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    fn1() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Myclass &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">id: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(id)</span><br><span class="line">    &#125;</span><br><span class="line">    childFn2(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// console.log(this.id)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="属性存取器"><a href="#属性存取器" class="headerlink" title="属性存取器"></a>属性存取器</h5><p>对于一些不希望被任意修改的属性，可以将其设置为private，直接将其设置为private将导致无法再通过对象修改其中的属性，我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person&#123;</span><br><span class="line">    <span class="keyword">private</span> _name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取器</span></span><br><span class="line">    <span class="keyword">get</span> name()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改器</span></span><br><span class="line">    <span class="keyword">set</span> name(name: <span class="built_in">string</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取器/修改器 ES6中也存在（set/get）</p><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>通过继承可以将其他类中的属性和方法引入到当前类中</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> B <span class="keyword">extends</span> B &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> Parent1 &#123;</span><br><span class="line">    <span class="comment">/* public name:string;</span></span><br><span class="line"><span class="comment">  constructor(name:string)&#123;</span></span><br><span class="line"><span class="comment">    this.name = name;</span></span><br><span class="line"><span class="comment">  &#125;*/</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Child1 <span class="keyword">extends</span> Parent1 &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> id: <span class="built_in">number</span>, name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>抽象类不能被实例化，只能被继承；给类中的方法定义规范；抽象类中可以没有抽象方法，抽象方法如果存在，在继承它的类中一定要实现，否则编译报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> A&#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">abstract</span> run(): <span class="built_in">void</span>;</span><br><span class="line">    fn()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'AAA'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B <span class="keyword">extends</span> A &#123;</span><br><span class="line">    <span class="comment">// 实现抽象方法</span></span><br><span class="line">    run()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'冲起来~'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>主要负责定义一个类的结构，类要实现此接口后，此类只有包含接口定义的所有属性和方法才能定义成功。关键词：<code>interface/implements</code>。</p><p>类接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    <span class="comment">//name属性必须实现</span></span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="comment">//可以有，可以没有</span></span><br><span class="line">    id?: <span class="built_in">number</span></span><br><span class="line">    say():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Student <span class="keyword">implements</span> Person&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">    say() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'大家好，我是'</span>+<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> searchInterface &#123;</span><br><span class="line">    (kw: <span class="built_in">string</span>, page?: <span class="built_in">number</span>): <span class="built_in">string</span>[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> searchFn: searchInterface = (kw:<span class="built_in">string</span>):<span class="built_in">string</span>[] =&gt; [<span class="string">'aaa'</span>, <span class="string">'bbb'</span>]</span><br></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定）, 此时泛型便能够发挥作用。</p><h5 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h5><p>在没有没学过泛型之前可以使用，但是这样使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="title">any</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里的&lt;T&gt;就是泛型；T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型；所以泛型其实很好理解，就表示某个类型；</span></span><br><span class="line"><span class="comment">//直接使用</span></span><br><span class="line">test(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//指定类型</span></span><br><span class="line">test&lt;<span class="built_in">number</span>&gt;(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//函数中声明多个泛型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt;(<span class="params">a: T, b: K</span>): <span class="title">K</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line">test&lt;<span class="built_in">number</span>, <span class="built_in">string</span>&gt;(<span class="number">10</span>, <span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure><h5 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyClass&lt;T&gt;&#123;</span><br><span class="line">    num!: T;</span><br><span class="line"><span class="keyword">constructor</span>(<span class="params">num: T</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.num = num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> MyClass&lt;<span class="built_in">number</span>&gt;(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 泛型继承</span></span><br><span class="line"><span class="keyword">interface</span> MyInter&#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">MyInter</span>&gt;(<span class="params">arg: T</span>): <span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TypeScript&quot;&gt;&lt;a href=&quot;#TypeScript&quot; class=&quot;headerlink&quot; title=&quot;TypeScript&quot;&gt;&lt;/a&gt;TypeScript&lt;/h2&gt;&lt;p&gt;数组、元组、自定义、联合类型；断言；TS编译配置；TS类概念；泛型&lt;/p&gt;
    
    </summary>
    
    
      <category term="TypeScript" scheme="http://ankang.icu/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>模块化与TypeScript的基本数据类型</title>
    <link href="http://ankang.icu/2021/04/27/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8ETypeScript%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://ankang.icu/2021/04/27/模块化与TypeScript的基本数据类型/</id>
    <published>2021-04-27T14:57:43.000Z</published>
    <updated>2021-04-28T13:51:25.813Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p><strong>方案</strong>：AMD[requirejs]、CMD[seajs]、CommonJS[nodejs]和ES6</p><p><em>AMD和CMD</em>，两者的<strong>区别</strong>是前者是对于依赖的模块提前执行，而后者是延迟执行。 前者推崇依赖前置，而后者推崇依赖就近，即只在需要用到某个模块的时候再require。</p><p>CMD 有async方法实现异步</p><a id="more"></a><h5 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h5><p>非同步加载模块，允许指定回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块，没有依赖项</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'你好fn1'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 导出模块</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        fn1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 定义模块有这依赖项</span></span><br><span class="line">define([<span class="string">'m1'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">m1</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'m2模块'</span>, m1.fn1());</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 暴露模块</span></span><br><span class="line">    <span class="keyword">return</span> &#123; fn2 &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 入口文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    requirejs.config(&#123;</span><br><span class="line">        <span class="comment">// 配置js路径</span></span><br><span class="line">        paths: &#123;</span><br><span class="line">            m1: <span class="string">'./module/m1'</span>,</span><br><span class="line">            m2: <span class="string">'./module/m2'</span>,</span><br><span class="line">            jquery: <span class="string">'./module/jquery'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    requirejs([<span class="string">'m2'</span>, <span class="string">' jquery'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">m2</span>) </span>&#123;</span><br><span class="line">        m2.fn2();</span><br><span class="line">        $(<span class="string">'#box'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">1111</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 页面文件</span></span><br><span class="line">&lt;div id=<span class="string">"box"</span>&gt;点击试一下&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script data-main="./m</span>ain.js<span class="string">" src="</span>./lib/<span class="built_in">require</span>.js<span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h5 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"m1模块下面的fn1方法"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 导出模块</span></span><br><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">        fn1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 导入依赖模块</span></span><br><span class="line">    <span class="keyword">let</span> m1 = <span class="built_in">require</span>(<span class="string">'./m1'</span>)</span><br><span class="line">    m1.fn1()</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我是m2模块下面的fn2方法'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    exports.fn2 = fn2</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 主入口文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m2 = <span class="built_in">require</span>(<span class="string">'./m2'</span>)</span><br><span class="line">    m2.fn2()</span><br><span class="line">    <span class="keyword">let</span> jquery = <span class="built_in">require</span>(<span class="string">'./jquery'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(jquery(<span class="string">'body'</span>));</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 页面</span></span><br><span class="line">&lt;script src=<span class="string">"./lib/sea.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    seajs.use('./m</span>odule/main.js<span class="string">')</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h5 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h5><p>前端浏览器不支持，Nodejs中使用的是这个规范，核心思想就是通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = 对象</span><br><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">const</span> 变量 = <span class="built_in">require</span>(路径)</span><br></pre></td></tr></table></figure><h5 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h5><p>在ES6中，我们可以使用 import 关键字引入模块，通过 exprot 关键字导出模块，功能较之于前几个方案更为强大，也是我们所推崇的，但是由于ES6模块化目前还无法在所有的浏览器中支持，所以在浏览器中使用需要进行编译处理。目前chrome是支持的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> [<span class="keyword">default</span>] 对象</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> obj form <span class="string">'路径'</span></span><br><span class="line"><span class="keyword">import</span> xxx form <span class="string">'路径'</span></span><br><span class="line"><span class="keyword">import</span> &#123;xx <span class="keyword">as</span> 别名&#125; <span class="keyword">from</span> <span class="string">'路径'</span></span><br></pre></td></tr></table></figure><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。</p><p><img src="/2021/04/27/模块化与TypeScript的基本数据类型/img1.png" alt="image-20210427192231042">下载完nodejs后可以切换npm镜像</p><blockquote><p>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p></blockquote><p>也可以安装nrm–镜像源管理，高版本会报错，安装目录下找到 <code>cli.js</code>文件在17行，修改如下：</p><blockquote><p>const NRMRC = path.join(process.env[(process.platform == ‘win32’) ? ‘USERPROFILE’ : ‘HOME’], ‘.nrmrc’);</p></blockquote><p>使用npm全局安装TypeScript</p><blockquote><p>npm i -g typescript</p><p>//安装完成查看</p><p>tsc -v</p></blockquote><p>通过tsc命令对ts文件进行编译 <code>tsc app ts</code></p><p><img src="/2021/04/27/模块化与TypeScript的基本数据类型/img2.png" alt="image-20210427193235016"></p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>类型声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app:类型</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">p1:类型,p2:类型</span>):类型</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>自动类型：</p><p>当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型，工作中建议还是手动指明变量类型，尽量少的去让TS自动判断类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="string">"Hello"</span></span><br><span class="line"><span class="built_in">console</span>.log(app);</span><br></pre></td></tr></table></figure><h5 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h5 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: <span class="built_in">number</span> = <span class="number">6</span>;           <span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">let</span> hexLiteral: <span class="built_in">number</span> = <span class="number">0xf00d</span>;     <span class="comment">// 十六进制</span></span><br><span class="line"><span class="keyword">let</span> binaryLiteral: <span class="built_in">number</span> = <span class="number">0b1010</span>;  <span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> octalLiteral: <span class="built_in">number</span> = <span class="number">0o744</span>;    <span class="comment">// 八进制</span></span><br></pre></td></tr></table></figure><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">"bob"</span></span><br><span class="line"><span class="keyword">let</span> username:<span class="built_in">string</span> = <span class="string">`aaabbbccc`</span></span><br></pre></td></tr></table></figure><h5 id="any-unknown"><a href="#any-unknown" class="headerlink" title="any/unknown"></a>any/unknown</h5><p>any任意类型, 类型安全的any类型；当前定义的变量，不知道是什么类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> app:<span class="built_in">any</span> = <span class="number">66</span></span><br><span class="line"><span class="keyword">let</span> app:unknown = <span class="number">66</span></span><br></pre></td></tr></table></figure><h5 id="void"><a href="#void" class="headerlink" title="void"></a>void</h5><p>表示没有任何类型，只能赋值为undefined和null，一般常用于返回返回值的声明，如果一个函数没有返回值，就可以用它。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"This is my warning message"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h5><h5 id="never"><a href="#never" class="headerlink" title="never"></a>never</h5><p>表示那些永不存在的值的类型，也在函数执行判断时，永不可能执行到的代码块。</p><p><img src="/2021/04/27/模块化与TypeScript的基本数据类型/img3.png" alt="image-20210427194331157"></p><h5 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h5><p>可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color: <span class="string">'red'</span> | <span class="string">'blue'</span> | <span class="string">'green'</span>;</span><br><span class="line"><span class="keyword">let</span> num: <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>使用枚举类型可以为一组数值赋予特定的值。</p><p>使用时，如果定义的枚举内部没有指定值，则默认从0开始；如果设置枚举的值为数值，则后面未设置的值向下累加；如果设置的值为字符串，需要全部设置；常量定义的枚举，不可直接打印类型，但是可以通过 <code>.</code>读取到里面的值；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue,</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">    Red = <span class="number">1</span>,</span><br><span class="line">    Green = <span class="number">2</span>,</span><br><span class="line">    Blue = <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure><h5 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: object = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> obj:&#123;id:<span class="built_in">number</span>,name?:<span class="built_in">string</span>&#125;  <span class="comment">// ?可选</span></span><br><span class="line"><span class="comment">// id是必须要有的，后面可以任意key，key为字符串，值为任意类型</span></span><br><span class="line"><span class="keyword">let</span> obj:&#123;id:<span class="built_in">number</span>,[props:<span class="built_in">string</span>]:<span class="built_in">any</span>&#125;</span><br><span class="line"><span class="comment">// 给函数参数定义类型和返回值定义类型</span></span><br><span class="line"><span class="keyword">type</span> fnType = <span class="function">(<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span></span>)=&gt;</span><span class="built_in">number</span></span><br><span class="line"><span class="keyword">const</span> fn:fnType = (a:<span class="built_in">number</span>,b:<span class="built_in">number</span>):<span class="function"><span class="params">number</span>=&gt;</span>a+b</span><br></pre></td></tr></table></figure><p><img src="/2021/04/27/模块化与TypeScript的基本数据类型/img4.png" alt="image-20210427195919260"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;模块化&quot;&gt;&lt;a href=&quot;#模块化&quot; class=&quot;headerlink&quot; title=&quot;模块化&quot;&gt;&lt;/a&gt;模块化&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;方案&lt;/strong&gt;：AMD[requirejs]、CMD[seajs]、CommonJS[nodejs]和ES6&lt;/p&gt;
&lt;p&gt;&lt;em&gt;AMD和CMD&lt;/em&gt;，两者的&lt;strong&gt;区别&lt;/strong&gt;是前者是对于依赖的模块提前执行，而后者是延迟执行。 前者推崇依赖前置，而后者推崇依赖就近，即只在需要用到某个模块的时候再require。&lt;/p&gt;
&lt;p&gt;CMD 有async方法实现异步&lt;/p&gt;
    
    </summary>
    
    
      <category term="TypeScript" scheme="http://ankang.icu/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>new/call/bind/instanceof的实现与代理</title>
    <link href="http://ankang.icu/2021/04/26/new-call-bind-instanceof%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BB%A3%E7%90%86/"/>
    <id>http://ankang.icu/2021/04/26/new-call-bind-instanceof的实现与代理/</id>
    <published>2021-04-26T14:53:00.000Z</published>
    <updated>2021-04-28T13:51:50.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h5 id="重写new"><a href="#重写new" class="headerlink" title="重写new"></a>重写new</h5><p>new内部过程：创建一个实例对象，this指向当前这个实例对象，会自动把函数执行，但是this内部指向变为实例对象，返回值没有或者是基本值，则返回实例对象；如果是引用值，以定义好的为主。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个实例对象</span></span><br><span class="line">    <span class="comment">// this指向实例对象</span></span><br><span class="line">    <span class="comment">// 也会像普通函数执行一样，让其执行，只不过this指向实例对象</span></span><br><span class="line">    <span class="comment">// 返回值没有或基本值，则返回实例对象，如果引用值，以自己的为主</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> Fn()</span><br><span class="line"><span class="comment">// ===============================================================</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">Construct, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个实例对象（创建Construct类的实例，让其 对象.__proto__ = Construct.prototype）</span></span><br><span class="line">    <span class="comment">// obj.__proto__ = Construct.prototype</span></span><br><span class="line">    <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(Construct.prototype)</span><br><span class="line">    <span class="comment">// 把函数执行，让this指向实例对象</span></span><br><span class="line">    <span class="keyword">let</span> ret = Construct.call(obj, ...args)</span><br><span class="line">    <span class="comment">//  处理返回值，引用类型,直接返回引用类型的值</span></span><br><span class="line">    <span class="keyword">if</span> (ret !== <span class="literal">null</span> &amp;&amp; <span class="regexp">/^(object|function)$/</span>.test(<span class="keyword">typeof</span> ret)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'方法==='</span> + <span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f1 = _new(Fn, <span class="string">'张三'</span>)</span><br><span class="line">f1.age()</span><br></pre></td></tr></table></figure><h5 id="重写call和bind"><a href="#重写call和bind" class="headerlink" title="重写call和bind"></a>重写call和bind</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">ctx, ...params</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 参数可以为 undefined或null</span></span><br><span class="line">    ctx = ctx == <span class="literal">null</span> ? <span class="built_in">window</span> : ctx</span><br><span class="line">    <span class="comment">// 需要保证ctx必须是对象类型的值:因为只有对象才能设置属性</span></span><br><span class="line">    ctx = !<span class="regexp">/^(object|function)$/</span>.test(<span class="keyword">typeof</span> ctx) ? <span class="built_in">Object</span>(ctx) : ctx</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> ret = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 新增的属性名保证唯一性，防止污染原始对象中的成员数据</span></span><br><span class="line">    <span class="keyword">let</span> functionName = <span class="built_in">Symbol</span>(<span class="string">'functionName'</span>)</span><br><span class="line">    <span class="comment">// 给对象添加属性</span></span><br><span class="line">    ctx[functionName] = self</span><br><span class="line">    <span class="comment">// 执行方法</span></span><br><span class="line">    ret = ctx[functionName](...params)</span><br><span class="line">    <span class="comment">// 删除自定义属性</span></span><br><span class="line">    <span class="keyword">delete</span> ctx[functionName]</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, x, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'张三'</span></span><br><span class="line">&#125;</span><br><span class="line">fn.myCall(obj, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h5 id="重写bind"><a href="#重写bind" class="headerlink" title="重写bind"></a>重写bind</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> <span class="title">myBind</span>(<span class="params">ctx, ...params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        self.apply(ctx, [...params, ...args])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, args)</span><br><span class="line">&#125;</span><br><span class="line">btn.onclick = fn.bind(obj, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h5 id="重写instanceof"><a href="#重写instanceof" class="headerlink" title="重写instanceof"></a>重写<code>instanceof</code></h5><p>不能检测基本数据类型,检测的实例必须是对象；</p><p>检测原理：构造函数<code>Symbol.hasInstance</code>属性，检测构造函数的prototype是否出现在实例的<code>__proto__</code>上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_instanceof</span>(<span class="params">obj, FC</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> FC !== <span class="string">"function"</span>) &#123;</span><br><span class="line">        <span class="comment">// 抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'类型不能，无法使用'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 检查是否有Symbol.hasInstance属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> hasIns = FC[<span class="built_in">Symbol</span>.hasInstance]</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> hasIns === <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行返回true/false</span></span><br><span class="line">            <span class="keyword">return</span> hasIns.call(FC, obj)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不支持Symbol</span></span><br><span class="line">    <span class="comment">// 获取类的原型</span></span><br><span class="line">    <span class="keyword">let</span> prototype = FC.prototype</span><br><span class="line">    <span class="comment">// 获取实例的原型</span></span><br><span class="line">    <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(obj)</span><br><span class="line">    <span class="comment">// 如果类没有prototype则直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!prototype) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到原型链最顶，还没有找到返回false</span></span><br><span class="line">        <span class="keyword">if</span> (proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 在原型上找到返回true</span></span><br><span class="line">        <span class="keyword">if</span> (proto === prototype) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        proto = <span class="built_in">Object</span>.getPrototypeOf(proto)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = _instanceof(<span class="number">1</span>, <span class="built_in">Array</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure><h5 id="代理拦截"><a href="#代理拦截" class="headerlink" title="代理拦截"></a>代理拦截</h5><p><code>Object.defineProperty</code>：ES5方法，该方法可以在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。但是无法监听数组变化。其中属性 <code>enumerable</code>不可枚举；<code>configurable</code>是否可以删除；<code>value</code>属性值；<code>writable</code>属性是否可修改。</p><p><code>Proxy</code>：ES6提供的新的api，Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><ul><li>Proxy可以直接监听对象而非属性。</li><li>Proxy直接可以劫持整个对象,并返回一个新对象,不管是操作便利程度还是底层功能上都远强于Object.defineProperty。</li><li>Proxy可以直接监听数组的变化。</li><li>有多达13种拦截方法,不限于<code>apply、ownKeys、deleteProperty、has</code>等等是Object.defineProperty不具备的。</li></ul><p><img src="/2021/04/26/new-call-bind-instanceof的实现与代理/image1.png" alt="image-20210426230342845"></p><p><img src="/2021/04/26/new-call-bind-instanceof的实现与代理/image2.png" alt="image-20210426230349251"></p><h4 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h4><p>Reflect对象与Proxy对象一样，也是ES6为了操作对象而提供的新API。Reflect对象的设计目的有这样几个。</p><ul><li>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。</li><li>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</li><li>让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</li><li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</li></ul><p>它拥有的API和Proxy一一对应。</p><p><code>Object.defineProperty:enumerable</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h2&gt;&lt;h5 id=&quot;重写new&quot;&gt;&lt;a href=&quot;#重写new&quot; class=&quot;headerlink&quot; title=&quot;重写new&quot;&gt;&lt;/a&gt;重写new&lt;/h5&gt;&lt;p&gt;new内部过程：创建一个实例对象，this指向当前这个实例对象，会自动把函数执行，但是this内部指向变为实例对象，返回值没有或者是基本值，则返回实例对象；如果是引用值，以定义好的为主。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://ankang.icu/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://ankang.icu/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>类/原型与原型链</title>
    <link href="http://ankang.icu/2021/04/25/%E7%B1%BB-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://ankang.icu/2021/04/25/类-原型与原型链/</id>
    <published>2021-04-25T01:03:29.000Z</published>
    <updated>2021-04-27T15:00:24.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h5 id="构造函数和普通函数"><a href="#构造函数和普通函数" class="headerlink" title="构造函数和普通函数"></a>构造函数和普通函数</h5><p>相同点：</p><p>定义的方式，都是通过function来定义</p><p>执行时参数传递方式一样</p><p>都会形成私有上下文，都有私有变量</p><p>不同点：</p><p>构造函数执行通过<code>new</code>来执行，在执行时浏览器会在当前上下文中<strong>创建一个实例对象</strong>，并且会让函数中的<strong>this指向</strong>到这个实例对象中，而普通函数中的this指向为window。</p><p>函数如过没有返回值或返回值为基本类型值，则返回<code>undefined</code>或你指定的返回值;如果是构造函数，它没有返回值，则返回当前的<strong>实例对象</strong>，如果有返回值，返回值是基本类型则也是返回当前对象，当返回的是引用类型，则返回你所指定的类型。</p><p>构造函数：箭头函数没有this，不能当构造函数，箭头函数没有prototype；ES6简写没有prototype；</p><a id="more"></a><h5 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h5><p>箭头函数没有prototype原型属性；ES6简写没有prototype；</p><p>每一个函数数据类型都自带一个<strong>prototype原型</strong>属性，属性值是一个对象，并且对象中自带一个属性为：<code>constructor</code>，属性值是当前构造函数本身。</p><p>每一个对象数据类型都自带一个<code>__proto__</code>原型链属性，属性值是所属类的<code>prototype</code>原型对象。</p><p>prototype也是一个对象，每一个类new出来的实例对象从prototype原型对象中继承属性；对象中包含 <code>__proto__</code>指向类的原型对象，原型中包含<code>constructor</code>属性，指向构造函数。</p><p><strong>原型链</strong>：在对象的私有属性中查找结果，如果私有中存在就是用私有的（优先级最高），如果不存在，则基于<code>__proto__</code>找所属类prototype上的属性，再找prototype的 <code>__proto__</code>上的属性，直到<code>Object.prototype</code>为止，报错。原型链查找。</p><p><img src="/2021/04/25/类-原型与原型链/image-1.png" alt="image-1"></p><p>获取对象的原型方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Fn.prototype.a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> o = <span class="keyword">new</span> Fn;</span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(o.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(o));</span><br></pre></td></tr></table></figure><p><code>Object.create()</code>：会创建一个空对象，基于传入的对象来创建，</p><h5 id="获取与设置原型"><a href="#获取与设置原型" class="headerlink" title="获取与设置原型"></a>获取与设置原型</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置一个指定的对象的原型</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(对象，父对象);</span><br><span class="line"><span class="comment">// 指定对象的原型</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(对象)</span><br><span class="line"><span class="keyword">let</span> child = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> parent = &#123; <span class="attr">id</span>: <span class="number">100</span> &#125;;</span><br><span class="line"><span class="comment">// child.__proto__ = parent;//IE不兼容</span></span><br><span class="line"><span class="comment">// 设置child.__proto__的原型指向到parent</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(child, parent);</span><br></pre></td></tr></table></figure><h5 id="原型重定向"><a href="#原型重定向" class="headerlink" title="原型重定向"></a>原型重定向</h5><p>原型重定向会引发constructor丢失，手动添加constructor属性，是可以通过for in枚举出来的，默认这个属性是不可以的。</p><p>设置对象属性不可枚举</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给对象添加一个属性，并且给属性添加一些描述, 不可枚举</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Fn.prototype, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">    <span class="comment">// 指定值</span></span><br><span class="line">    value: Fn,</span><br><span class="line">    <span class="comment">// 不可枚举</span></span><br><span class="line">    enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 如果你要用prototype重定向，推荐写法</span></span><br><span class="line"><span class="built_in">Object</span>.assign(Fn.prototype, &#123;</span><br><span class="line">    getA() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'getA'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    getB() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'getB'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="原型检测"><a href="#原型检测" class="headerlink" title="原型检测"></a>原型检测</h5><p><code>instanceof</code> 检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上，只要能找到则为真，检查对象是否属于某个类；使用<code>isPrototypeOf</code>检测一个对象是否是另一个对象的原型链中；</p><p>在ES6以后，先查找当前对象是否有Symbol，通过 <code>Symbol.hasInstance</code>方法，把要比较的对象放到此方法中，返回true/false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(myInstanceof(<span class="built_in">Array</span>, arr))</span><br><span class="line"><span class="comment">// 封装，只适用于es6之后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">FC, obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在类中查找是否存在 Symbol.hasInstance方法</span></span><br><span class="line">    <span class="keyword">let</span> ins = FC[<span class="built_in">Symbol</span>.hasInstance]</span><br><span class="line">    <span class="keyword">if</span> (ins &amp;&amp; <span class="keyword">typeof</span> ins === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用</span></span><br><span class="line">        <span class="keyword">return</span> ins.call(FC, obj)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="原型扩展方法"><a href="#原型扩展方法" class="headerlink" title="原型扩展方法"></a>原型扩展方法</h5><p>可以实现链式写法、限定调取方法的类型，必须是指定类型的实例</p><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p><strong>封装</strong>：类也是一个函数,把实现一个功能的代码进行封装，以此实现“低耦合高内聚”。</p><p><strong>多态</strong>：重写： 子类重写父类上的方法（伴随着继承运行的）； 重载： 相同的方法，由于参数或者返回值不同，具备了不同的功能（js中不具备严格意义上的重载）。</p><p><strong>继承</strong>： 子类继承父类中的方法和属性。</p><p><strong>方式</strong>：</p><p>原型继承 (让子类的原型 = 父类实例)、call继承（只能继承父类中私有的，不能继承父类中公共的）、寄生组合式继承（call继承 + 原型继承）、混合继承（间接实现多继承）</p><p>原型继承：把父类中的私有方法，都在子类中变成公有的，让子类的prototype = 父类。</p><p>call/apply继承：把父类当普通函数执行，所以prototype丢失，但是让this指向还要指向到当前的对象中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h2&gt;&lt;h5 id=&quot;构造函数和普通函数&quot;&gt;&lt;a href=&quot;#构造函数和普通函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数和普通函数&quot;&gt;&lt;/a&gt;构造函数和普通函数&lt;/h5&gt;&lt;p&gt;相同点：&lt;/p&gt;
&lt;p&gt;定义的方式，都是通过function来定义&lt;/p&gt;
&lt;p&gt;执行时参数传递方式一样&lt;/p&gt;
&lt;p&gt;都会形成私有上下文，都有私有变量&lt;/p&gt;
&lt;p&gt;不同点：&lt;/p&gt;
&lt;p&gt;构造函数执行通过&lt;code&gt;new&lt;/code&gt;来执行，在执行时浏览器会在当前上下文中&lt;strong&gt;创建一个实例对象&lt;/strong&gt;，并且会让函数中的&lt;strong&gt;this指向&lt;/strong&gt;到这个实例对象中，而普通函数中的this指向为window。&lt;/p&gt;
&lt;p&gt;函数如过没有返回值或返回值为基本类型值，则返回&lt;code&gt;undefined&lt;/code&gt;或你指定的返回值;如果是构造函数，它没有返回值，则返回当前的&lt;strong&gt;实例对象&lt;/strong&gt;，如果有返回值，返回值是基本类型则也是返回当前对象，当返回的是引用类型，则返回你所指定的类型。&lt;/p&gt;
&lt;p&gt;构造函数：箭头函数没有this，不能当构造函数，箭头函数没有prototype；ES6简写没有prototype；&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://ankang.icu/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://ankang.icu/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>节流/防抖与对象</title>
    <link href="http://ankang.icu/2021/04/22/%E8%8A%82%E6%B5%81-%E9%98%B2%E6%8A%96%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>http://ankang.icu/2021/04/22/节流-防抖与对象/</id>
    <published>2021-04-22T14:29:28.000Z</published>
    <updated>2021-04-26T01:26:32.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h2><ul><li><p>函数防抖和函数节流都是防止某一时间频繁触发，但是这两者之间的原理却不一样。</p></li><li><p>函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。</p></li></ul><h5 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h5><p>在高频操作下，只识别一次触发（事件的开始时刻或者结束时刻），实现：一般设置一个阈值，在阈值内无论操作多少次，程序只执行一次。</p><h5 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h5><p>高频操作下，按照规定好的时间为间隔触发一次，等待变化一会在执行程序，避免资源浪费。规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟一段ajax请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ajax request '</span> + content)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//防抖</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fun, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">let</span> _args = args</span><br><span class="line">        clearTimeout(fun.id)</span><br><span class="line">        fun.id = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            fun.call(that, _args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inputb = <span class="built_in">document</span>.getElementById(<span class="string">'debounce'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> debounceAjax = debounce(ajax, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">inputb.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    debounceAjax(e.target.value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="节流-1"><a href="#节流-1" class="headerlink" title="节流"></a>节流</h5><p>高频操作下，按照规定好的时间为间隔触发一次，等待变化一会在执行程序，避免资源浪费。规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fun, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> last, deferTimer</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">let</span> _args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        <span class="keyword">if</span> (last &amp;&amp; now &lt; last + delay) &#123;</span><br><span class="line">            clearTimeout(deferTimer)</span><br><span class="line">            deferTimer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                last = now</span><br><span class="line">                fun.apply(that, _args)</span><br><span class="line">            &#125;, delay)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            last = now</span><br><span class="line">            fun.apply(that,_args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> throttleAjax = throttle(ajax, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inputc = <span class="built_in">document</span>.getElementById(<span class="string">'throttle'</span>)</span><br><span class="line">inputc.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    throttleAjax(e.target.value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h5 id="对象计算比较："><a href="#对象计算比较：" class="headerlink" title="对象计算比较："></a>对象计算比较：</h5><p>对象计算时首先查找有没有<code>Symbol.toPrimiative</code>属性，如果有，根据此属性方法的返回值来计算；<code>Symbol.toPrimiative</code>–<code>valueOf</code>–<code>toString</code>顺序选择；</p><p>如果是字符串连接操作，<code>toString</code>的优先级比<code>valueOf</code>高；条件比较则相反。</p><h5 id="解构赋值："><a href="#解构赋值：" class="headerlink" title="解构赋值："></a>解构赋值：</h5><p>原则：看右侧数据，如果是对象，需要保证赋值对象的key相同，如果是数组，名称随意，左右类型相同。如果多个引用类型的名称，采用起别名的方式。</p><h5 id="属性管理："><a href="#属性管理：" class="headerlink" title="属性管理："></a>属性管理：</h5><p>属性检查：<code>hasOwnProperty</code> 用来检查指定名称是否为当前对象的<em>私有属性</em>；<code>in</code> 关键字可以检查共有属性，<em>先私有后公有</em>,在私有属性中没有找到会通过<strong>proto</strong>原型链向下去查找，如果查到最后还没有返回false ，找到返回true</p><p>实现检查当前属性是否为共有：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(!obj.hasOwnProperty(<span class="string">'name'</span>) &amp;&amp; (<span class="string">'name'</span> <span class="keyword">in</span> obj));</span><br></pre></td></tr></table></figure><p>公有属性(原型或原型链上的)和私有属性(构造方法中)</p><h5 id="获取属性名"><a href="#获取属性名" class="headerlink" title="获取属性名"></a>获取属性名</h5><p><code>Object.keys()</code>和<code>Object.getOwnPropertyNames()</code>：获取对象中所有非Symbol类型的私有属性方法，以数组返回；<code>Object.getOwnPropertySymbols()</code>：只获取Symbol的私有属性方法，以数组返回；<code>Object.definePropertie({},&#39;aa&#39;,{enumerable:false})</code>：设置属性不可枚举，循环不可以读出，不可以直接被调用，起到一个保护作用。使用for…in…可以迭代原型链中所有可枚举的属性。</p><h5 id="禁止向对象添加属性"><a href="#禁止向对象添加属性" class="headerlink" title="禁止向对象添加属性"></a>禁止向对象添加属性</h5><p><code>Object.preventExtensions(obj)</code>：禁止向对象添加属性，对原有属性可以修改。严格模式下，设置禁止添加属性，但程序中存在添加代码，会报错，后续代码不执行。</p><h5 id="冻结对象"><a href="#冻结对象" class="headerlink" title="冻结对象"></a>冻结对象</h5><p><code>Object.freeze(obj)</code>：冻结后的对象不可修改，—将对象定义为一个常量。严格模式下，对已经冻结的对象修改和添加属性会报错，后续代码不执行；非严格模式下，没有效果不报错。可以通过<code>Object.isFrozen(obj)</code>检查当前对象是否为冻结对象。</p><h5 id="获取器与修改器"><a href="#获取器与修改器" class="headerlink" title="获取器与修改器"></a>获取器与修改器</h5><h5 id="对象属性私有化"><a href="#对象属性私有化" class="headerlink" title="对象属性私有化"></a>对象属性私有化</h5><h5 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h5>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;防抖与节流&quot;&gt;&lt;a href=&quot;#防抖与节流&quot; class=&quot;headerlink&quot; title=&quot;防抖与节流&quot;&gt;&lt;/a&gt;防抖与节流&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;函数防抖和函数节流都是防止某一时间频繁触发，但是这两者之间的原理却不一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;防抖&quot;&gt;&lt;a href=&quot;#防抖&quot; class=&quot;headerlink&quot; title=&quot;防抖&quot;&gt;&lt;/a&gt;防抖&lt;/h5&gt;&lt;p&gt;在高频操作下，只识别一次触发（事件的开始时刻或者结束时刻），实现：一般设置一个阈值，在阈值内无论操作多少次，程序只执行一次。&lt;/p&gt;
&lt;h5 id=&quot;节流&quot;&gt;&lt;a href=&quot;#节流&quot; class=&quot;headerlink&quot; title=&quot;节流&quot;&gt;&lt;/a&gt;节流&lt;/h5&gt;&lt;p&gt;高频操作下，按照规定好的时间为间隔触发一次，等待变化一会在执行程序，避免资源浪费。规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://ankang.icu/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://ankang.icu/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>作用域与闭包</title>
    <link href="http://ankang.icu/2021/04/21/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
    <id>http://ankang.icu/2021/04/21/作用域与闭包/</id>
    <published>2021-04-21T11:43:44.000Z</published>
    <updated>2021-04-22T13:35:41.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>全局作用域、函数作用域、块级作用域</p><p>作用域链会向上查找，找到全局window时中止==&gt;not defined；函数被执行后其环境变量将从内存中删除，函数每次调用会创建一个新作用域。</p><p>如果子函数将被使用时，父级环境将保留，不会被释放。===闭包</p><p>块级作用域-ES6中添加的，使用let/const 定义的具有块级作用域，var没有块级作用域</p><a id="more"></a><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul><li><p>保护私有上下文中的私有变量”和外界互不影响。</p></li><li><p>私有上下文中的“私有变量”和“值”都会被保存起来，可以供其下级上下文中使用。</p></li><li><p>如果使用闭包，会导致栈内存太大，页面渲染变慢，性能受到影响，所以在项目中需要合理应用闭包。</p></li><li><p>模块化开发</p></li></ul><h5 id="惰性调用：条件判断只执行一次，以后不在进行判断"><a href="#惰性调用：条件判断只执行一次，以后不在进行判断" class="headerlink" title="惰性调用：条件判断只执行一次，以后不在进行判断"></a>惰性调用：条件判断只执行一次，以后不在进行判断</h5><h5 id="柯里化：预处理思想，使用闭包形成一个不被释放的上下文，把一些信息存储起来-以后基于作用域链，访问到事先存储的信息，然后进行相关的处理"><a href="#柯里化：预处理思想，使用闭包形成一个不被释放的上下文，把一些信息存储起来-以后基于作用域链，访问到事先存储的信息，然后进行相关的处理" class="headerlink" title="柯里化：预处理思想，使用闭包形成一个不被释放的上下文，把一些信息存储起来,以后基于作用域链，访问到事先存储的信息，然后进行相关的处理"></a>柯里化：预处理思想，使用闭包形成一个不被释放的上下文，把一些信息存储起来,以后基于作用域链，访问到事先存储的信息，然后进行相关的处理</h5><h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><p>this,函数的执行主体(不等价于执行上下文),取决于谁把这个函数执行的。大体上把this执行主体分为以下几类：</p><ul><li>事件绑定中的this</li><li>普通函数执行中的this</li><li>箭头函数执行中的this</li><li>构造函数中的 this</li><li>基于call/apply/bind强制改变中的this</li></ul><p><strong>事件绑定中</strong>的this指向除了IE的attachEvent方式为window外，都是指向当前侦听的DOM对象；普通函数执行中，<strong>非严格模式</strong>下，this指向<em>window</em>，<strong>严格模式</strong>下，指向为undefined，<strong>对象中</strong>函数的this指向调用该函数的对象，<strong>对象调用</strong>在全局下就是<em>window</em>；<strong>闭包中</strong>的this一般都是指向<em>window</em>；<strong>回调函数中</strong>的this一般指向<em>window</em>；<strong>自执行函数中</strong>的this指向<em>window</em>；<strong>箭头函数中</strong>没有自己的this，所用的this都是所处上下文中的this—用来保留上下文this指向；</p><ul><li><p>call</p></li><li><p>apply</p></li><li><p>bind</p></li></ul><p>call和apply都是立即执行函数，函数.call(指向对象,[…参数])，实现思路：先给参数1添加一个属性方法并且让这个属性值赋值为函数，执行自定义属性方法，删除刚刚添加的自定义属性方法； </p><p><code>call</code>执行的函数，如果有参数，以逗号为间隔一个个传入，<code>apply</code>执行时，如果函数有参数，以<code>数组形式</code>传入。在<strong>非严格模式</strong>下，<code>call</code>方法传入null/undefined或者不传，this指向会变成window，<strong>严格模式</strong>下，写谁指向谁，如果指向对象为空，则指向undefined；<code>bind</code>调用的方法不会立即执行，指挥给预先处理好，等待被执行，如果函数有参数，则和call的参数传递一样；<em>call的性能高于apply</em>；</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h2&gt;&lt;p&gt;全局作用域、函数作用域、块级作用域&lt;/p&gt;
&lt;p&gt;作用域链会向上查找，找到全局window时中止==&amp;gt;not defined；函数被执行后其环境变量将从内存中删除，函数每次调用会创建一个新作用域。&lt;/p&gt;
&lt;p&gt;如果子函数将被使用时，父级环境将保留，不会被释放。===闭包&lt;/p&gt;
&lt;p&gt;块级作用域-ES6中添加的，使用let/const 定义的具有块级作用域，var没有块级作用域&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://ankang.icu/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://ankang.icu/tags/ES6/"/>
    
      <category term="闭包" scheme="http://ankang.icu/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Jquery之尺寸/位置/网络请求</title>
    <link href="http://ankang.icu/2021/04/20/Jquery%E4%B9%8B%E5%B0%BA%E5%AF%B8-%E4%BD%8D%E7%BD%AE-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    <id>http://ankang.icu/2021/04/20/Jquery之尺寸-位置-网络请求/</id>
    <published>2021-04-20T11:40:56.000Z</published>
    <updated>2021-04-21T11:43:02.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Jquery："><a href="#Jquery：" class="headerlink" title="Jquery："></a>Jquery：</h2><h4 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h4><p>获取元素的宽高：width()–返回数值类型</p><ul><li>当有参数时（数字）表示设置宽高</li></ul><p>包含内边距：–只能获取，返回数值类型，不能设置</p><ul><li>innerWidth()</li></ul><p>包含边框和宽高（如果参数为true-&gt;表示包括外边距）：</p><ul><li>outerWidth()</li></ul><h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p>获取、设置元素相对于文档的偏移坐标和父级没有关系，返回为对象{top,left}，值为数值；设置时参数为对象类型</p><ul><li>offset()</li></ul><p>获取、设置元素被卷去的头部和左侧距离</p><ul><li>scrollTop([数字])/scrollLeft([数字])</li></ul><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先设置window的监听</span></span><br><span class="line">$(<span class="built_in">window</span>).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//滚动的距离获取文档对象</span></span><br><span class="line">    <span class="built_in">console</span>.log($(<span class="built_in">document</span>).scrollTop());</span><br><span class="line">    <span class="comment">//设置</span></span><br><span class="line">    <span class="comment">//$(document).scrollTop(0);</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>相对于带有定位的父级偏移坐标，如果父级没有定位，则以文档为准，值为对象</p><ul><li>position</li></ul><h4 id="extend"><a href="#extend" class="headerlink" title="extend()"></a>extend()</h4><p>对象浅或深拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$.extend([deep(<span class="literal">true</span>/<span class="literal">false</span>[默认])],target,source1,[scource2...]);</span><br><span class="line"><span class="comment">//浅复制：只复制引用类型的第一层基本类型</span></span><br></pre></td></tr></table></figure><h4 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>(URL,callback);//<span class="keyword">get</span>请求</span><br><span class="line">$.post(URL,data,callback);//post请求</span><br><span class="line">$.ajax(&#123;<span class="comment">//标准写法</span></span><br><span class="line">    url:’请求地址’,</span><br><span class="line">    type:’GET/POST/PUT/DELTE’, <span class="comment">// 请求http方法</span></span><br><span class="line">    timeout:<span class="number">10</span>,<span class="comment">// 请求超时时间（毫秒）</span></span><br><span class="line">    headers:&#123;&#125;,<span class="comment">// 请求添加的额外头信息</span></span><br><span class="line">    data:&#123;&#125;/string, <span class="comment">// 请求体数据</span></span><br><span class="line">    dataType:’json/jsonp’,<span class="comment">// 服务器返回数据类型</span></span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;&#125;,<span class="comment">// 请求成功回调</span></span><br><span class="line">    error:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="comment">// 请求失败回调</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Promise.all()、Promise.race()</p><p>race：只要有一个执行完成，不管执行成功或者失败，程序结束；all：等待所有的promise完成，程序才结束，并且所有的promise一个都不能有错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = $.ajax(&#123;</span><br><span class="line">    url:<span class="string">"请求地址"</span>,</span><br><span class="line">    type:<span class="string">"请求方式"</span>,</span><br><span class="line">    dataType:<span class="string">"服务器返回数据类型"</span>,</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br><span class="line"><span class="built_in">Promise</span>.all([p1,...,pn]).then(<span class="function">(<span class="params">r1,...,rn</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [r1.data,...,rn.data];</span><br><span class="line">    <span class="built_in">console</span>.log(arr);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="第三方插件"><a href="#第三方插件" class="headerlink" title="第三方插件"></a>第三方插件</h4><p><a href="http://www.htmleaf.com/jQuery/pubuliuchajian/" target="_blank" rel="noopener">插件</a></p><h4 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给原型添加方法</span></span><br><span class="line">$.fn.方法 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;&#125;)(jQuery);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Jquery：&quot;&gt;&lt;a href=&quot;#Jquery：&quot; class=&quot;headerlink&quot; title=&quot;Jquery：&quot;&gt;&lt;/a&gt;Jquery：&lt;/h2&gt;&lt;h4 id=&quot;尺寸&quot;&gt;&lt;a href=&quot;#尺寸&quot; class=&quot;headerlink&quot; title=&quot;尺寸&quot;&gt;&lt;/a&gt;尺寸&lt;/h4&gt;&lt;p&gt;获取元素的宽高：width()–返回数值类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当有参数时（数字）表示设置宽高&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;包含内边距：–只能获取，返回数值类型，不能设置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;innerWidth()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;包含边框和宽高（如果参数为true-&amp;gt;表示包括外边距）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;outerWidth()&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;位置&quot;&gt;&lt;a href=&quot;#位置&quot; class=&quot;headerlink&quot; title=&quot;位置&quot;&gt;&lt;/a&gt;位置&lt;/h4&gt;&lt;p&gt;获取、设置元素相对于文档的偏移坐标和父级没有关系，返回为对象{top,left}，值为数值；设置时参数为对象类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;offset()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;获取、设置元素被卷去的头部和左侧距离&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scrollTop([数字])/scrollLeft([数字])&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://ankang.icu/tags/JavaScript/"/>
    
      <category term="深复制/浅复制" scheme="http://ankang.icu/tags/%E6%B7%B1%E5%A4%8D%E5%88%B6-%E6%B5%85%E5%A4%8D%E5%88%B6/"/>
    
      <category term="Jquery" scheme="http://ankang.icu/tags/Jquery/"/>
    
  </entry>
  
  <entry>
    <title>Jquery对象与基本设置</title>
    <link href="http://ankang.icu/2021/04/19/Jquery%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/"/>
    <id>http://ankang.icu/2021/04/19/Jquery对象与基本设置/</id>
    <published>2021-04-19T00:01:55.000Z</published>
    <updated>2021-04-21T11:42:19.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Jquery："><a href="#Jquery：" class="headerlink" title="Jquery："></a>Jquery：</h2><p>1.x 版本支持IE6、7、8低版本浏览器，官方不再更新</p><h3 id="入口函数："><a href="#入口函数：" class="headerlink" title="入口函数："></a>入口函数：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../js/jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">$(document).ready(function()&#123;&#125;)</span><br><span class="line">//或者</span><br><span class="line">$(function()&#123;&#125;)</span><br></pre></td></tr></table></figure><p>入口函数可以在一个页面多次使用，表示页面结构加载完成。jQuery中的this指向已经处理，不建议在jQuery下使用箭头函数。</p><a id="more"></a><h3 id="jQuery对象与DOM对象："><a href="#jQuery对象与DOM对象：" class="headerlink" title="jQuery对象与DOM对象："></a>jQuery对象与DOM对象：</h3><p>通过原生JS的<code>getElementById</code>等方法获取的元素对象称为DOM对象。使用jQuery的<code>$</code>对象获取的元素称为jQuery对象。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//获取DOM对象</span><br><span class="line">let elem = document.getElementById("username");</span><br><span class="line">//转为jQuery对象</span><br><span class="line">console.log($(elem));</span><br><span class="line">//获取jQuery对象</span><br><span class="line">let jelem = $("#username");</span><br><span class="line">//转为DOM对象</span><br><span class="line">$("#username")[0];//$("#username").get(0)</span><br></pre></td></tr></table></figure><h3 id="选择器："><a href="#选择器：" class="headerlink" title="选择器："></a>选择器：</h3><h5 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h5><p>分为全选选择器、ID选择器、类选择器、标签选择器、并集选择器；其中并集选择器==群组选择器。jQuery具备隐式迭代。</p><p>在使用并集选择器，进行事件绑定时，箭头函数的指向问题：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$('ul,ol').click(ev=&gt;&#123;</span><br><span class="line">//$(ev.target);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h5><p>子代选择器（<code>$(&#39;ul&gt;li&#39;)</code>）、后代选择器（<code>$(&#39;ul li&#39;)</code>）</p><h5 id="筛选选择器"><a href="#筛选选择器" class="headerlink" title="筛选选择器"></a>筛选选择器</h5><p><code>:first</code>获取该选择器的第一个元素，<code>:last</code>获取最后一个元素，<code>:eq(index)</code>获取选择器中索引值为index的元素，<code>:odd</code>：索引值为奇数的元素，<code>:even</code>：索引值为偶数的元素。</p><blockquote><p>$(‘li:first’)：第一个li元素</p></blockquote><h3 id="筛选方法："><a href="#筛选方法：" class="headerlink" title="筛选方法："></a>筛选方法：</h3><ul><li><code>parent()</code>查找父类</li><li><code>parents()</code>查找其指定的父类</li><li><code>children()</code>相当于子代选择器</li><li><code>find()</code>相当于后代选择器</li><li><code>siblings()</code>查找元素的兄弟元素，但不包括自己本身</li><li><code>nextAll()</code>查找当前元素之后所有的同辈元素</li><li><code>prevAll()</code>查找当前元素之前所有的同辈元素</li><li><code>eq()</code>相当于筛选选择器中的eq</li></ul><h3 id="样式设置："><a href="#样式设置：" class="headerlink" title="样式设置："></a>样式设置：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//获取样式:</span><br><span class="line">$(选择器).css('样式名称');</span><br><span class="line">//设置样式:</span><br><span class="line">$(选择器).css('样式名称','值');</span><br><span class="line">//同时设置多个样式</span><br><span class="line">$(选择器).css(&#123;'样式名称1':'值1', '样式名称2':'值2'&#125;);</span><br><span class="line">//添加样式:</span><br><span class="line">$(选择器).addClass(‘样式名称’);</span><br><span class="line">//删除样式:</span><br><span class="line">$(选择器).removeClass(‘样式名称’);</span><br></pre></td></tr></table></figure><h3 id="属性操作："><a href="#属性操作：" class="headerlink" title="属性操作："></a>属性操作：</h3><h5 id="元素固有属性："><a href="#元素固有属性：" class="headerlink" title="元素固有属性："></a>元素固有属性：</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取</span><br><span class="line">$(选择器).prop('属性名')</span><br><span class="line">//设置</span><br><span class="line">$(选择器).prop('属性名', '值')</span><br></pre></td></tr></table></figure><h5 id="自定义属性："><a href="#自定义属性：" class="headerlink" title="自定义属性："></a>自定义属性：</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取</span><br><span class="line">$(选择器).attr('属性名')</span><br><span class="line">//设置</span><br><span class="line">$(选择器).attr('属性名', '值')</span><br></pre></td></tr></table></figure><h3 id="元素文本内容："><a href="#元素文本内容：" class="headerlink" title="元素文本内容："></a>元素文本内容：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//HTML内容：</span><br><span class="line">//获取：</span><br><span class="line">$(选择器).html()</span><br><span class="line">//设置：</span><br><span class="line">$(选择器).html('内容')</span><br><span class="line"></span><br><span class="line">//文本内容:</span><br><span class="line">//获取:</span><br><span class="line">$(选择器).text()</span><br><span class="line">//设置：</span><br><span class="line">$(选择器).text('内容')</span><br><span class="line"></span><br><span class="line">//表单值内容：</span><br><span class="line">$(选择器).val()//获取</span><br><span class="line">$(选择器).val('内容')//设置</span><br></pre></td></tr></table></figure><h3 id="元素操作："><a href="#元素操作：" class="headerlink" title="元素操作："></a>元素操作：</h3><h5 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// each方法遍历元素</span><br><span class="line">$(选择器).each(function((index,domEl)&#123;&#125;)</span><br><span class="line">$.each($(选择器),function((index,domEl)&#123;&#125;)</span><br></pre></td></tr></table></figure><h5 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var jqelem = $('<span class="tag">&lt;<span class="name">div</span>&gt;</span>你好世界<span class="tag">&lt;/<span class="name">div</span>&gt;</span>')//创建</span><br></pre></td></tr></table></figure><h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><ul><li>添加一个子元素</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 内容放入匹配内容最后面</span><br><span class="line">$(选择器).append(jqelem);</span><br><span class="line">// 内容放在最前面</span><br><span class="line">$(选择器).prepend(jqelem);</span><br></pre></td></tr></table></figure><ul><li>添加一个兄弟元素</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 放到匹配元素的后面</span><br><span class="line">$(选择器).after(jqelem);</span><br><span class="line">// 放到匹配元素的前面</span><br><span class="line">$(选择器).before(jqelem);</span><br></pre></td></tr></table></figure><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//删除元素本身</span><br><span class="line">$(选择器).remove();</span><br><span class="line">//删除匹配的元素集合中所有的子节点</span><br><span class="line">$(选择器).empty();</span><br><span class="line">$(选择器).html('');</span><br></pre></td></tr></table></figure><p><a href="https://jquery.cuishifeng.cn" target="_blank" rel="noopener">接口文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Jquery：&quot;&gt;&lt;a href=&quot;#Jquery：&quot; class=&quot;headerlink&quot; title=&quot;Jquery：&quot;&gt;&lt;/a&gt;Jquery：&lt;/h2&gt;&lt;p&gt;1.x 版本支持IE6、7、8低版本浏览器，官方不再更新&lt;/p&gt;
&lt;h3 id=&quot;入口函数：&quot;&gt;&lt;a href=&quot;#入口函数：&quot; class=&quot;headerlink&quot; title=&quot;入口函数：&quot;&gt;&lt;/a&gt;入口函数：&lt;/h3&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;../js/jquery.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$(document).ready(function()&amp;#123;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//或者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$(function()&amp;#123;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;入口函数可以在一个页面多次使用，表示页面结构加载完成。jQuery中的this指向已经处理，不建议在jQuery下使用箭头函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://ankang.icu/tags/JavaScript/"/>
    
      <category term="Jquery" scheme="http://ankang.icu/tags/Jquery/"/>
    
  </entry>
  
  <entry>
    <title>Promise中的then方法理解</title>
    <link href="http://ankang.icu/2021/04/17/Promise%E4%B8%AD%E7%9A%84then%E6%96%B9%E6%B3%95%E7%90%86%E8%A7%A3/"/>
    <id>http://ankang.icu/2021/04/17/Promise中的then方法理解/</id>
    <published>2021-04-17T00:06:01.000Z</published>
    <updated>2021-04-19T00:08:04.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop:"></a>Event Loop:</h2><p>同步任务、异步任务</p><h5 id="宏任务："><a href="#宏任务：" class="headerlink" title="宏任务："></a>宏任务：</h5><ul><li><p>setTimeout</p></li><li><p>setInterval</p></li></ul><h5 id="微任务："><a href="#微任务：" class="headerlink" title="微任务："></a>微任务：</h5><ul><li>Promise</li></ul><a id="more"></a><h2 id="Promise："><a href="#Promise：" class="headerlink" title="Promise："></a>Promise：</h2><p>先执行同步任务，当执行到宏任务时，开辟<strong>新任务列</strong>放在最顶端执行；当遇到微任务时，放在当前任务列的最低端执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function"><span class="keyword">function</span> (<span class="params">resolve,reject</span>) </span>&#123;</span><br><span class="line">resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>. Log(<span class="string">"a"</span>);</span><br><span class="line">&#125;，<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve();</span><br><span class="line">&#125;). then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"b"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);<span class="comment">//b,a</span></span><br></pre></td></tr></table></figure><p>Promise.then()方法提供一个供自定义的回调函数，如果上一个函数的返回值非函数，则会忽略当前的then方法，回调函数结束会把程序的返回值传给下一个then方法中的函数当作参数使用。没有返回值默认为undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'返回值'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cb = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'新的值'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定义了两个函数，对不同情况进行分析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cb();</span><br><span class="line">&#125;).then(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(resp);</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">'1 =========&lt;'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//新的值</span></span><br><span class="line"><span class="comment">//1 =========&lt;</span></span><br></pre></td></tr></table></figure><p><code>return cb()</code>表示执行cb函数，并将其结果（新的值）返回出去，在下一个then方法中resp接收了上一个then方法返回值的值（新的值）作为自己回调函数的参数使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;).then(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(resp);</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">'2 =========&lt;'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//undefined</span></span><br><span class="line"><span class="comment">//2 =========&lt;</span></span><br></pre></td></tr></table></figure><p>因为第一个then方法中只是执行了cb方法，而没有return返回值，默认下一个then方法的参数为undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func().then(cb()).then(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(resp);</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">'3 =========&lt;'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line"><span class="comment">//3 =========&lt;</span></span><br></pre></td></tr></table></figure><p>第一个then方法中<code>cb()</code>函数先执行，结果为（新的值）非函数，官方文档中要求若传入then方法的参数不是函数，当前then方法必须被忽略：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func().then(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(resp);</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">'3 =========&lt;'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所以func()的返回结果直接传给then()方法中的回调函数作为参数resp的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func().then(cb).then(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(resp);</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">'4 =========&lt;'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line"><span class="comment">//4 =========&lt;</span></span><br></pre></td></tr></table></figure><p>关键在于第一个then方法的参数为<code>cb</code>=== <code>then(function(){return &#39;新的值&#39;})</code>；与第一个实例有同样的效果，同时也满足then方法中要传入一个函数的要求。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Event-Loop&quot;&gt;&lt;a href=&quot;#Event-Loop&quot; class=&quot;headerlink&quot; title=&quot;Event Loop:&quot;&gt;&lt;/a&gt;Event Loop:&lt;/h2&gt;&lt;p&gt;同步任务、异步任务&lt;/p&gt;
&lt;h5 id=&quot;宏任务：&quot;&gt;&lt;a href=&quot;#宏任务：&quot; class=&quot;headerlink&quot; title=&quot;宏任务：&quot;&gt;&lt;/a&gt;宏任务：&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;setTimeout&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;setInterval&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;微任务：&quot;&gt;&lt;a href=&quot;#微任务：&quot; class=&quot;headerlink&quot; title=&quot;微任务：&quot;&gt;&lt;/a&gt;微任务：&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;Promise&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://ankang.icu/tags/JavaScript/"/>
    
      <category term="异步" scheme="http://ankang.icu/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="ES6" scheme="http://ankang.icu/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>cookie/localstorage</title>
    <link href="http://ankang.icu/2021/04/16/cookie-localstorage/"/>
    <id>http://ankang.icu/2021/04/16/cookie-localstorage/</id>
    <published>2021-04-16T02:04:23.000Z</published>
    <updated>2021-04-17T02:07:34.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie:"></a>cookie:</h2><p>会话跟踪技术</p><ul><li><p>会默认在请求头里面携带</p></li><li><h5 id="前端cookie"><a href="#前端cookie" class="headerlink" title="前端cookie"></a>前端cookie</h5></li><li><p>一套协议域名端口对应一套cookie</p></li><li><p>存储在当前浏览器独立创建的本地文件</p></li><li><p>cookie里面存储的信息是纯文本形式的</p></li><li><p>cookie里面存储信息最大4kb，最大条数为50</p></li><li><p>时效性：默认 session</p></li><li><p>cookie是必须同域名，同协议，同端口的页面才可以访问</p></li><li><p>浏览器通过 协议+域名+端口作为key值，cookie作为value，实现映射结构的数据存储</p></li><li><p>cookie是有安全限制; (很像作用域 / 以文件夹为单位的父子级包裹关系，决定了cookie的可访问性)</p></li><li><p>cookie的所有特征都是用字符串去描述的</p></li></ul><a id="more"></a><ul><li><p>获取cookie：<code>document.cookie</code></p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"username=123456"</span>;</span><br></pre></td></tr></table></figure></li><li><p>domain 一般不设置;</p><ul><li>早期用来做跨域</li></ul></li><li><p>cookie设置时一条cookie的所有信息都放在一个字符串上;</p></li><li><p>需要设置path</p><ul><li>不同path的cookie不是同一条cookie;</li></ul></li><li><p>设置expires : 过期时间;</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">d.setDate( d.getDate() + <span class="number">15</span> );</span><br><span class="line"><span class="comment">// console.log(d);</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"username=456789;path=/GP23;expires="</span> + d;</span><br></pre></td></tr></table></figure></li><li><p>cookie获取：</p></li><li><p>取出的cookie都用 ;空格 去进行间隔;</p></li><li><p><code>console.log(document.cookie);</code></p></li><li><h5 id="后端cookie"><a href="#后端cookie" class="headerlink" title="后端cookie"></a>后端cookie</h5></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setCookie  设置cookie;</span><br><span class="line">$_COOKIE   获取cookie;</span><br></pre></td></tr></table></figure></li></ul><h2 id="localstorage："><a href="#localstorage：" class="headerlink" title="localstorage："></a>localstorage：</h2><p>在当前浏览器，持久存储数据的技术我们称之为本地存储技术</p><ul><li><h5 id="特定于页面的协议"><a href="#特定于页面的协议" class="headerlink" title="特定于页面的协议"></a>特定于页面的协议</h5></li><li><h5 id="localStorage-中的键值对总是以字符串的形式存储。"><a href="#localStorage-中的键值对总是以字符串的形式存储。" class="headerlink" title="localStorage 中的键值对总是以字符串的形式存储。"></a><code>localStorage</code> 中的键值对总是以字符串的形式存储。</h5></li><li><p>键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem();</span><br><span class="line">localStorage.getItem();<span class="comment">//读取</span></span><br><span class="line">localStorage.key();<span class="comment">//返回数据中某个key值（下标）</span></span><br><span class="line">localStorage.removeItem();<span class="comment">//移除</span></span><br><span class="line">localStorage.clear();<span class="comment">//移除所有</span></span><br></pre></td></tr></table></figure><h2 id="JSON-stringify-："><a href="#JSON-stringify-：" class="headerlink" title="JSON.stringify()："></a>JSON.stringify()：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(value[, replacer [, space]])</span><br></pre></td></tr></table></figure><p>将一个 JavaScript 对象或值转换为 JSON 字符串，如果指定了一个 replacer 函数，则可以选择性地替换值，或者指定的 replacer 是数组，则可选择性地仅包含数组指定的属性。</p><h2 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h2><p>无论请求还是响应格式都是http规定的格式</p><p>请求报文：</p><ul><li>请求行：<ul><li>http协议版本：1.1</li><li>请求方式：GET   POST    PATCH    PUT    DELETE</li></ul></li><li>请求头：</li><li>请求空行</li><li>请求体（请求方式为POST）</li></ul><p>请求字段：</p><ul><li><p>GET：放在url之中</p></li><li><p>POST：放在请求体之中</p></li></ul><p>响应报文：</p><ul><li>响应行<ul><li>http协议版本 / 响应状态码</li><li>1* : 准备状态 用不着看不到的状态; </li><li>2 : 成功状态; </li><li>3 : 重定向状态;</li><li>4 : 请求错误 ; </li></ul></li><li>响应头</li><li>响应体</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;cookie&quot;&gt;&lt;a href=&quot;#cookie&quot; class=&quot;headerlink&quot; title=&quot;cookie:&quot;&gt;&lt;/a&gt;cookie:&lt;/h2&gt;&lt;p&gt;会话跟踪技术&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;会默认在请求头里面携带&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h5 id=&quot;前端cookie&quot;&gt;&lt;a href=&quot;#前端cookie&quot; class=&quot;headerlink&quot; title=&quot;前端cookie&quot;&gt;&lt;/a&gt;前端cookie&lt;/h5&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一套协议域名端口对应一套cookie&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;存储在当前浏览器独立创建的本地文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;cookie里面存储的信息是纯文本形式的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;cookie里面存储信息最大4kb，最大条数为50&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;时效性：默认 session&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;cookie是必须同域名，同协议，同端口的页面才可以访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;浏览器通过 协议+域名+端口作为key值，cookie作为value，实现映射结构的数据存储&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;cookie是有安全限制; (很像作用域 / 以文件夹为单位的父子级包裹关系，决定了cookie的可访问性)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;cookie的所有特征都是用字符串去描述的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Server" scheme="http://ankang.icu/tags/Server/"/>
    
  </entry>
  
  <entry>
    <title>CORS跨域/async-await/fetch</title>
    <link href="http://ankang.icu/2021/04/15/CORS%E8%B7%A8%E5%9F%9F-async-await-fetch/"/>
    <id>http://ankang.icu/2021/04/15/CORS跨域-async-await-fetch/</id>
    <published>2021-04-15T01:58:12.000Z</published>
    <updated>2021-04-17T02:01:39.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CORS跨域："><a href="#CORS跨域：" class="headerlink" title="CORS跨域："></a>CORS跨域：</h2><ul><li>CORS跨域是后端响应头的配置</li><li>CORS跨域主要是服务端配置的</li><li>在后端语言之中配置</li></ul><h2 id="promise"><a href="#promise" class="headerlink" title="promise:"></a>promise:</h2><h5 id="异步："><a href="#异步：" class="headerlink" title="异步："></a>异步：</h5><ul><li><p>主要用来解决异步回调地狱问题</p></li><li><p>Promise:承诺</p></li><li><h5 id="状态："><a href="#状态：" class="headerlink" title="状态："></a>状态：</h5><ul><li>pendding：正在进行；</li><li>fulfilled：成功履行承诺</li><li>rejected：没有遵守承诺</li></ul></li><li><p>承诺的状态一旦发生改变，那么这个状态不可逆</p></li></ul><a id="more"></a><ul><li><p>创建：</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">fulfill,reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// fulfill 是改变promsie对象状态为成功的工具函数</span></span><br><span class="line">    <span class="comment">// reject   改变promise对象状态为失败的工具函数</span></span><br><span class="line">    <span class="comment">//fulfill();</span></span><br><span class="line">    <span class="comment">//reject();</span></span><br><span class="line">    setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        fulfill();</span><br><span class="line">    &#125; , <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(promise)</span><br></pre></td></tr></table></figure></li><li><p>内部工具函数的执行是同步的，只要promise对象被创建出来，函数一定会被执行</p></li><li><p>一般会主动定义promise对象状态改变的规则</p></li><li><p>使用异步程序改变promise状态</p></li><li><p>promise对象创建 : </p><ul><li>调用 Promise构造函数; </li><li>传入 resolver 函数; </li><li>在 resolver 函数之中定义状态改变规则; </li></ul></li><li><h5 id="状态监听函数："><a href="#状态监听函数：" class="headerlink" title="状态监听函数："></a>状态监听函数：</h5></li><li><ul><li><code>then()</code>监听promise状态的改变；</li><li><code>catch()</code>监听promise状态改变为rejected；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p.catch( <span class="function"><span class="keyword">function</span>(<span class="params"> err </span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"hello error"</span>;</span><br><span class="line">&#125;<span class="keyword">catch</span>( e )&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>finally()</code>：只要状态改变了就会进入这个函数中；状态改变不做数据的处理</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params"> fulfill , reject </span>)</span>&#123;</span><br><span class="line">    fulfill( <span class="string">"hello world"</span> );</span><br><span class="line">&#125;)</span><br><span class="line">p.finally(<span class="function"><span class="keyword">function</span>(<span class="params"> res </span>)</span>&#123;</span><br><span class="line">    <span class="comment">// res : 是undefined; </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"状态改变就会执行"</span> , res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><h5 id="then-fn1-fn2-："><a href="#then-fn1-fn2-：" class="headerlink" title="then( fn1 , fn2 )："></a>then( fn1 , fn2 )：</h5></li><li><p>fn1：成功的时候会调用的回调函数</p></li><li><p>fn2：失败的时候会调用的回调函数</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"状态变为成功"</span>);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"状态变为失败"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><h5 id="then方法的返回值："><a href="#then方法的返回值：" class="headerlink" title="then方法的返回值："></a>then方法的返回值：</h5></li><li><p>回调函数中没有写return的情况下，返回值为promise对象</p></li><li><p>函数中写了return，新的promise对象的情况下，返回值就是新的promise对象</p></li><li><p>注意：</p></li><li><p>使用then之后可以去返回一个新的promsie对象用以连缀</p></li></ul><h2 id="async-await"><a href="#async-await" class="headerlink" title="async-await:"></a>async-await:</h2><h5 id="async"><a href="#async" class="headerlink" title="async:"></a>async:</h5><ul><li><p>用于定义函数的关键字–异步</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>async定义的函数默认的返回值是promise对象</p></li><li><p>只是返回一个promise对象，不能取代promise对象的构造</p></li></ul><h5 id="await"><a href="#await" class="headerlink" title="await:"></a>await:</h5><ul><li>只能在async定义的函数中使用</li><li>会等待promise对象状态变为成功，并且把then里面的参数返回出来</li><li>将异步回调函数写法变为了同步的代码写法</li><li>await之前的代码都是同步程序</li><li>await后面的所有程序都是异步的</li></ul><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch:"></a>fetch:</h2><p>xhr 请求发送工具</p><ul><li><p>属于浏览器的高级封装</p></li><li><p>完全不兼容IE—PC端不能用</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch(url,options)</span><br></pre></td></tr></table></figure></li><li><p>返回值为promise</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 返回响应对象; </span></span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">"./01_cors.php"</span>);</span><br><span class="line">    <span class="comment">// 处理响应对象，决定响应数据的类型; </span></span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> response.text();</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line">load();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CORS跨域：&quot;&gt;&lt;a href=&quot;#CORS跨域：&quot; class=&quot;headerlink&quot; title=&quot;CORS跨域：&quot;&gt;&lt;/a&gt;CORS跨域：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CORS跨域是后端响应头的配置&lt;/li&gt;
&lt;li&gt;CORS跨域主要是服务端配置的&lt;/li&gt;
&lt;li&gt;在后端语言之中配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;promise&quot;&gt;&lt;a href=&quot;#promise&quot; class=&quot;headerlink&quot; title=&quot;promise:&quot;&gt;&lt;/a&gt;promise:&lt;/h2&gt;&lt;h5 id=&quot;异步：&quot;&gt;&lt;a href=&quot;#异步：&quot; class=&quot;headerlink&quot; title=&quot;异步：&quot;&gt;&lt;/a&gt;异步：&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;主要用来解决异步回调地狱问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Promise:承诺&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h5 id=&quot;状态：&quot;&gt;&lt;a href=&quot;#状态：&quot; class=&quot;headerlink&quot; title=&quot;状态：&quot;&gt;&lt;/a&gt;状态：&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;pendding：正在进行；&lt;/li&gt;
&lt;li&gt;fulfilled：成功履行承诺&lt;/li&gt;
&lt;li&gt;rejected：没有遵守承诺&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;承诺的状态一旦发生改变，那么这个状态不可逆&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Server" scheme="http://ankang.icu/tags/Server/"/>
    
      <category term="异步" scheme="http://ankang.icu/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="Ajax" scheme="http://ankang.icu/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>Promise.then/JSONP跨域</title>
    <link href="http://ankang.icu/2021/04/14/Promise-then-JSONP%E8%B7%A8%E5%9F%9F/"/>
    <id>http://ankang.icu/2021/04/14/Promise-then-JSONP跨域/</id>
    <published>2021-04-14T01:49:27.000Z</published>
    <updated>2021-04-17T02:01:15.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h2><p>同步实现优先于异步实现</p><ul><li>异步队列中如果先执行完会等待同步完成</li><li>子元素和父元素的侦听顺序</li></ul><p>Promise.then</p><p>GET和POST区别</p><p>JSONP跨域</p><a id="more"></a><h2 id="Promise："><a href="#Promise：" class="headerlink" title="Promise："></a>Promise：</h2><ul><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImage</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,rejrct</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> img=<span class="keyword">new</span> Image();</span><br><span class="line">        img.src=src;</span><br><span class="line">        img.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;</span><br><span class="line">        img.onerror=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">loadImage(<span class="string">"./img/1.jpg"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1加载完成"</span>);</span><br><span class="line">    <span class="keyword">return</span> loadImage(<span class="string">"./img/2.jpg"</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"2加载完成"</span>);</span><br><span class="line">    <span class="keyword">return</span> loadImage(<span class="string">"./img/3.jpg"</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"3加载完成"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>resolve和reject两个方法只能二选一执行</p></li><li><p>PromiseState初始值：pending;</p></li><li><p>当执行resolve函数时或者reject函数时，首先判断状态是不是pending，如果是pending，则运行调用相应的函数；如果不是pending，不执行后面的函数</p></li><li><p>resolve执行：fulfilled</p></li><li><p>reject执行：rejected</p></li><li><p>链式结构</p></li><li><p><code>Promise.all</code></p></li><li><p>当列表中每一个Promise全部执行完成resolve后，调用then中的函数，并且将resolve中的参数全部放在一个数组中共同返回</p></li><li><p><code>promise.race</code></p></li><li><p>若干个Promise最先完成执行的返回参数</p></li><li><p>resolve和reject只能传一个参数</p></li><li><p>回调函数–红绿灯</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showLight</span>(<span class="params">light,time</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!item) time=<span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(light);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;,time);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fns();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fns</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    showLight(<span class="string">"红灯"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> showLight(<span class="string">"黄灯"</span>);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> showLight(<span class="string">"绿灯"</span>);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        fns();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>连缀：</p><ul><li>在promise.then中如果连缀没有返回promise，会新创建一个，并且执行resolve。</li></ul><h2 id="GET和POST区别："><a href="#GET和POST区别：" class="headerlink" title="GET和POST区别："></a>GET和POST区别：</h2><ul><li>发送数据的大小<ul><li>POST 不限制数据发送大小</li><li>GET  限制数据发送大小 4KB</li></ul></li><li>安全性<ul><li>GET 更为安全的一种请求方式</li><li>POST 是存在风险的</li><li>数据放在请求头里还是放在请求体里差别不大</li></ul></li><li>性能<ul><li>POST 性能差</li><li>GET 性能好</li></ul></li><li>语义化差异<ul><li>POST 是INSERT行为</li><li>GET 是SELECT行为</li></ul></li></ul><h2 id="跨域："><a href="#跨域：" class="headerlink" title="跨域："></a>跨域：</h2><p>同源策略：</p><ul><li>协议</li><li>域名</li><li>端口</li></ul><p>限制：</p><ul><li><p>浏览器限制</p></li><li><p>仅限于浏览器和服务器交互会发生跨域限制</p></li><li><p>仅限于xhr对象发起请求会有跨域限制</p></li></ul><p>技术：</p><ul><li>JSONP</li><li>CORS</li><li>服务器代理</li></ul><p>JSONP：</p><ul><li>降权===&gt;只能发送GET请求</li><li>使用标签代替xhr发送请求</li><li>标签src可以规避同源策略问题</li><li>必须提前准备好函数体，配合请求过来的函数调用</li><li>请求的script标签必须放在全局函数声明之后</li></ul><p>优化：</p><ul><li>动态生成script标签</li><li>防止冗余标签，加载完成后删除</li></ul><p><img src="/2021/04/14/Promise-then-JSONP跨域/img.png" alt="状态码"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Web-Worker&quot;&gt;&lt;a href=&quot;#Web-Worker&quot; class=&quot;headerlink&quot; title=&quot;Web Worker&quot;&gt;&lt;/a&gt;Web Worker&lt;/h2&gt;&lt;p&gt;同步实现优先于异步实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;异步队列中如果先执行完会等待同步完成&lt;/li&gt;
&lt;li&gt;子元素和父元素的侦听顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Promise.then&lt;/p&gt;
&lt;p&gt;GET和POST区别&lt;/p&gt;
&lt;p&gt;JSONP跨域&lt;/p&gt;
    
    </summary>
    
    
      <category term="Server" scheme="http://ankang.icu/tags/Server/"/>
    
      <category term="ES6，异步" scheme="http://ankang.icu/tags/ES6%EF%BC%8C%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>前后端分离/Ajax</title>
    <link href="http://ankang.icu/2021/04/13/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB-Ajax/"/>
    <id>http://ankang.icu/2021/04/13/前后端分离-Ajax/</id>
    <published>2021-04-13T14:18:44.000Z</published>
    <updated>2021-04-13T14:22:07.654Z</updated>
    
    <content type="html"><![CDATA[<ol><li>前后端分离技术</li><li>PHP与MySQL数据库</li><li>Ajax–异步</li></ol><h2 id="http协议补充-请求携带数据"><a href="#http协议补充-请求携带数据" class="headerlink" title="http协议补充 - 请求携带数据"></a>http协议补充 - 请求携带数据</h2><ul><li>GET : GET 请求的数据全部放在url路径之中 ; </li><li>路径后方可以拼接php数据 <ul><li>url?key=value&amp;key2=value</li><li>使用GET请求携带的数据, 以key为键，以value为值 以组的形式进行发送; </li><li>每条数据都以key=value形式进行分割; </li></ul></li><li>我们通常把传递数据的key值称之为 <code>字段</code>;</li></ul><a id="more"></a><h2 id="php操作数据库"><a href="#php操作数据库" class="headerlink" title="php操作数据库"></a>php操作数据库</h2><ul><li><p>php是一个后端语言， 其核心职责之一就是操作数据库; </p></li><li><p>php本身给我们提供了一套操作数据库的工具 : mysqli </p><ul><li><ol><li>链接数据库 connect; </li></ol></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mysqli_connect("服务器路径" , "数据库账号" , "数据库密码" , "数据库名称")</span></span><br></pre></td></tr></table></figure></li><li><p>返回值有可能为 资源秘钥 ；也可能为空值; </p></li><li><ol start="2"><li>SQL语句执行工具  query ; </li></ol></li><li><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$insert_sql = <span class="string">"INSERT INTO `usertable` VALUES ('ankang' , '123123' , null)"</span>;</span><br><span class="line">$res = mysqli_query($con , $insert_sql);</span><br></pre></td></tr></table></figure></li><li><p>我们操作数据库还是需要sql语句; </p></li><li><ol start="3"><li>php查询数据库会返回一个资源类型，我们会对资源类型进行特殊处理 ; </li></ol><ul><li>fetch_all API ; </li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$array = mysqli_fetch_all($select_res,MYSQLI_ASSOC);</span><br><span class="line"><span class="keyword">echo</span> json_encode($array);</span><br></pre></td></tr></table></figure><ul><li>MYSQLI_ASSOC MYSQLI_NUM ;</li></ul></li><li><ol start="4"><li>error : 数据库报错信息; </li></ol></li><li><p>错误处理判断 <code>$con</code></p></li><li><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !$con )&#123;</span><br><span class="line">    <span class="comment">// API : die 终止全局代码执行 </span></span><br><span class="line">    <span class="comment">// API : mysqli_error($con) 报出当前连接的错误信息用于排错; </span></span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"数据库连接错误,错误信息:"</span> . mysqli_error($con));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqli_close($con);<span class="comment">//关闭数据库</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>引入连接数据库的文件</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(&quot;./02_php链接数据库.php&quot;);</span><br></pre></td></tr></table></figure></li><li><p>在php之中编写sql语句所有的表名称，以及字段名全都用<code></code> 反引号引起来; </p></li><li><p>我们表之中设置好类型为varchar的字符串，一定要在数据前面加上 ‘’ —把数据识别为varchar; </p></li></ul><h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><ul><li>使我们现代项目开发的核心思想; </li><li><p>前后端的开发效率不一致 ： </p><ul><li>后端慢 :  1. 业务逻辑 2. 数据库操作 3. 安全 </li><li>前端快 :  </li></ul></li><li><p>前后端职责进行明确的划分 : </p><ul><li>前端工作职责大多在使用浏览器发送请求，处理服务的响应; </li><li>后端的工作职责是做一个黑盒子; </li></ul></li><li><p>如何协作 : </p><ul><li>在项目开发之前就定义好请求和响应的规则; </li><li>我们需要书面格式的规则说明 =&gt; 面向前端的 =&gt; 接口文档; </li></ul></li></ul><h1 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h1><h2 id="接口路径"><a href="#接口路径" class="headerlink" title="接口路径"></a>接口路径</h2><ul><li>url : <a href="http://www.baidu.com/xxx.php" target="_blank" rel="noopener">http://www.baidu.com/xxx.php</a></li></ul><h2 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h2><ul><li>GET | POST | PATCH | PUT | DELETE </li></ul><h2 id="请求字段信息"><a href="#请求字段信息" class="headerlink" title="请求字段信息"></a>请求字段信息</h2><ul><li>username : string </li><li>password : string </li></ul><h2 id="返回数据实例"><a href="#返回数据实例" class="headerlink" title="返回数据实例"></a>返回数据实例</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"data"</span>  : <span class="string">"hello world"</span> &#125;</span><br></pre></td></tr></table></figure><ul><li>注意事项 : <ul><li><ol><li>定义的字段名必须是英文; </li></ol></li><li><ol start="2"><li>请求方式必须明确; </li></ol></li><li><ol start="3"><li>后端响应的数据必须是json格式;  </li></ol></li><li>“{“username” : “wuyanzu” , “password”:123456, “id” : 3 , “type” : “success”}”; </li><li>有一个API 可以把json字符串转换成对象数组类型; </li></ul></li></ul><h2 id="AJAX："><a href="#AJAX：" class="headerlink" title="AJAX："></a>AJAX：</h2><ul><li><p>异步的类型：</p><ul><li>事件; =&gt; 事件处理函数</li><li>定时器/延时器; =&gt; 定时器的回调函数</li><li>ajax</li><li>promise.then</li></ul></li><li><p>异步 JavaScript and xml</p></li><li><p>xhr：（小黄人）XMLHttpRequest</p><ul><li>无刷新发起浏览器请求</li><li>接收服务器的响应</li><li>发起请求–有三步</li><li>接收响应–一步</li></ul></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每一个请求都要创建一个新的xhr实例对象</span></span><br><span class="line"><span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">//请求是必须有目标，并且想要获取数据的</span></span><br><span class="line"><span class="comment">// - 请求目标</span></span><br><span class="line"><span class="comment">// - 请求方式</span></span><br><span class="line"><span class="keyword">var</span> url=<span class="string">""</span>;</span><br><span class="line">xhr.open(<span class="string">"GET"</span>,url)</span><br><span class="line"><span class="comment">//源路径与请求目标的路径同协议、同端口、同域名</span></span><br><span class="line"><span class="comment">//发送行为</span></span><br><span class="line">xhr.send();</span><br><span class="line"><span class="comment">//响应处理</span></span><br><span class="line"><span class="comment">// - xhr.readyState : xhr的请求状态</span></span><br><span class="line"><span class="comment">// - 0 ~ 4 五个状态 ; </span></span><br><span class="line"><span class="comment">// - 4 : 成功; </span></span><br><span class="line"><span class="comment">// - xhr.status : http状态码 ; </span></span><br><span class="line"><span class="comment">// 200 : 成功; </span></span><br><span class="line"><span class="comment">// 2开头的所有状态码都表示成功; </span></span><br><span class="line"><span class="comment">// -xhr.responseText:响应字符串数据</span></span><br><span class="line"><span class="comment">// -事件：onreadystatechange:判断xhr的状态/http的状态</span></span><br><span class="line"><span class="built_in">console</span>.log(xhr);</span><br></pre></td></tr></table></figure></li><li><p>jsonp：跨域技术</p></li><li><p>fetch：高级封装</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;前后端分离技术&lt;/li&gt;
&lt;li&gt;PHP与MySQL数据库&lt;/li&gt;
&lt;li&gt;Ajax–异步&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;http协议补充-请求携带数据&quot;&gt;&lt;a href=&quot;#http协议补充-请求携带数据&quot; class=&quot;headerlink&quot; title=&quot;http协议补充 - 请求携带数据&quot;&gt;&lt;/a&gt;http协议补充 - 请求携带数据&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;GET : GET 请求的数据全部放在url路径之中 ; &lt;/li&gt;
&lt;li&gt;路径后方可以拼接php数据 &lt;ul&gt;
&lt;li&gt;url?key=value&amp;amp;key2=value&lt;/li&gt;
&lt;li&gt;使用GET请求携带的数据, 以key为键，以value为值 以组的形式进行发送; &lt;/li&gt;
&lt;li&gt;每条数据都以key=value形式进行分割; &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;我们通常把传递数据的key值称之为 &lt;code&gt;字段&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Server" scheme="http://ankang.icu/tags/Server/"/>
    
      <category term="Ajax" scheme="http://ankang.icu/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>服务器端与PHP</title>
    <link href="http://ankang.icu/2021/04/12/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%B8%8EPHP/"/>
    <id>http://ankang.icu/2021/04/12/服务器端与PHP/</id>
    <published>2021-04-12T12:18:30.000Z</published>
    <updated>2021-04-13T00:04:17.525Z</updated>
    
    <content type="html"><![CDATA[<ol><li>服务器基础</li><li>HTTP协议</li><li>PHP</li></ol><a id="more"></a><h2 id="服务器："><a href="#服务器：" class="headerlink" title="服务器："></a>服务器：</h2><ul><li><p>局域网IP、公网IP、环回IP</p></li><li><h5 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h5></li><li><p>ipconfig</p></li></ul><h2 id="本机应用服务器软件："><a href="#本机应用服务器软件：" class="headerlink" title="本机应用服务器软件："></a>本机应用服务器软件：</h2><ul><li><p>根目录：服务器可以共享的文件–WWW</p></li><li><p>WWW之下的文件，子集目录</p></li></ul><h2 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h2><ul><li><p>可靠协议：发出去的数据，与接收方一致</p></li><li><p>TCP：一人掉线全员等待</p></li><li><p>HTTP：可靠协议</p></li></ul><h3 id="三次握手：主要是确保链接的可靠性"><a href="#三次握手：主要是确保链接的可靠性" class="headerlink" title="三次握手：主要是确保链接的可靠性"></a>三次握手：主要是确保链接的可靠性</h3><ul><li>服务器可以接收请求</li><li>客户端可以发送请求</li><li>客户端可以接收响应</li></ul><h3 id="发请求、接响应"><a href="#发请求、接响应" class="headerlink" title="发请求、接响应"></a>发请求、接响应</h3><ul><li><p>B=&gt;S: request</p></li><li><p>S=&gt;B: response</p></li></ul><h3 id="四次挥手断开连接：验证数据的完整性"><a href="#四次挥手断开连接：验证数据的完整性" class="headerlink" title="四次挥手断开连接：验证数据的完整性"></a>四次挥手断开连接：验证数据的完整性</h3><h3 id="四次挥手验证结束之后，本次交互断开连接"><a href="#四次挥手验证结束之后，本次交互断开连接" class="headerlink" title="四次挥手验证结束之后，本次交互断开连接"></a>四次挥手验证结束之后，本次交互断开连接</h3><ul><li>HTTPS: HTTP协议的加密版本!</li></ul><h3 id="HTTP报文："><a href="#HTTP报文：" class="headerlink" title="HTTP报文："></a>HTTP报文：</h3><ul><li><h5 id="请求报文（request）"><a href="#请求报文（request）" class="headerlink" title="请求报文（request）"></a>请求报文（request）</h5></li><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/<span class="number">1.1</span></span><br><span class="line"> </span><br><span class="line">     Host: www.baidu.com</span><br><span class="line">     Connection: keep-alive</span><br><span class="line">     Cache-Control: max-age=<span class="number">0</span></span><br><span class="line">     sec-ch-ua: <span class="string">"Chromium"</span>;v=<span class="string">"88"</span>, <span class="string">"Google Chrome"</span>;v=<span class="string">"88"</span>, <span class="string">";Not A Brand"</span>;v=<span class="string">"99"</span></span><br></pre></td></tr></table></figure></li><li><p>请求行：</p><ul><li>请求行（GET|POST|PUT|PATCH|DELETE）</li><li>请求头（配置信息）</li><li>请求空行</li><li>请求体（请求携带的数据）只在POST情况下携带请求体</li></ul></li><li><h5 id="响应报文（response）"><a href="#响应报文（response）" class="headerlink" title="响应报文（response）"></a>响应报文（response）</h5></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Bdpagetype: <span class="number">2</span></span><br><span class="line">Bdqid: <span class="number">0xb9f8696600063622</span></span><br><span class="line">Cache-Control: private</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure></li><li><p>响应行（协议版本，协议状态码）</p></li><li><p>响应头（响应内容描述）</p></li><li><p>响应体（preview和response中）</p></li></ul><h3 id="端口号："><a href="#端口号：" class="headerlink" title="端口号："></a>端口号：</h3><ul><li>计算机的端口 : 允许访问(请求)进入计算机的路径;  65535 个端口; </li><li>http协议：80</li><li>https协议：443</li></ul><h2 id="请求携带数据："><a href="#请求携带数据：" class="headerlink" title="请求携带数据："></a>请求携带数据：</h2><ul><li><p>方式：</p></li><li><blockquote><p>url?key=value&amp;key2=value</p></blockquote></li><li><p>使用GET请求携带的数据, 以key为健，以value为值 以组的形式进行发送; </p></li><li><p>每条数据都以key=value形式进行分割; </p></li><li><h5 id="我们通常把传递数据的key值称之为-字段"><a href="#我们通常把传递数据的key值称之为-字段" class="headerlink" title="我们通常把传递数据的key值称之为 字段;"></a>我们通常把传递数据的key值称之为 <code>字段</code>;</h5></li></ul><h3 id="同步实现优先于异步实现："><a href="#同步实现优先于异步实现：" class="headerlink" title="同步实现优先于异步实现："></a>同步实现优先于异步实现：</h3><h2 id="PHP："><a href="#PHP：" class="headerlink" title="PHP："></a>PHP：</h2><ul><li><p>使用 <code>&lt;?php</code>标识着php代码的开始</p></li><li><p><code>echo</code>关键字==翻译：回声===输出字符串</p></li></ul><h3 id="字符串输出："><a href="#字符串输出：" class="headerlink" title="字符串输出："></a>字符串输出：</h3><ul><li><p><code>‘’</code>纯字符串；</p></li><li><p><code>“”</code>：拼接字符串，可以在字符串里面直接写变量；</p></li><li><p>php中没有对象，只有数组</p></li><li><p><code>.</code>在运算在php中代表字符串拼接</p></li></ul><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><ul><li><h5 id="数字数组：下标-数值"><a href="#数字数组：下标-数值" class="headerlink" title="数字数组：下标==数值"></a>数字数组：下标==数值</h5></li><li><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$arr=<span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">echo</span> $arr;</span><br><span class="line"><span class="keyword">echo</span> var_dump($arr);</span><br><span class="line"><span class="keyword">echo</span> $arr[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">echo</span> count($arr);</span><br><span class="line"><span class="keyword">echo</span> sizeof($arr);</span><br></pre></td></tr></table></figure></li><li><p>echo输出数组会默认调用转换字符串的方法把自己转换为字符串</p></li><li><p>使用 <code>var_dump()</code>查看内部的内容和结构</p></li><li><p>数组中使用 <code>[]</code>取出内容</p></li><li><p>获取数组的长度===<code>sizeof/count</code></p></li><li><p>php一旦被请求，返回结果默认拼接字符串，一次性返回；</p></li><li><h5 id="关联数组：key-value"><a href="#关联数组：key-value" class="headerlink" title="关联数组：key==value"></a>关联数组：key==value</h5></li><li><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$assoc_array = <span class="keyword">array</span>( <span class="string">"key1"</span> =&gt; <span class="string">"value1"</span> );</span><br><span class="line"><span class="keyword">echo</span> var_dump($assoc_array);</span><br></pre></td></tr></table></figure></li><li><p>数据关联使用<code>=&gt;</code>进行；</p></li></ul><h3 id="前后端交互标准结构：JSON"><a href="#前后端交互标准结构：JSON" class="headerlink" title="前后端交互标准结构：JSON"></a>前后端交互标准结构：JSON</h3><ul><li>php将数组转换为符合json格式</li><li><code>json_encode()</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;服务器基础&lt;/li&gt;
&lt;li&gt;HTTP协议&lt;/li&gt;
&lt;li&gt;PHP&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Server" scheme="http://ankang.icu/tags/Server/"/>
    
  </entry>
  
  <entry>
    <title>Symbol/Set/Map与模块化开发</title>
    <link href="http://ankang.icu/2021/04/02/Symbol-Set-Map%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <id>http://ankang.icu/2021/04/02/Symbol-Set-Map与模块化开发/</id>
    <published>2021-04-02T11:13:35.000Z</published>
    <updated>2021-04-12T11:22:49.798Z</updated>
    
    <content type="html"><![CDATA[<ul><li>字符串方法</li><li>Symbol</li><li>Set/Map</li><li>模块化开发</li></ul><a id="more"></a><h3 id="字符串方法和Symbol"><a href="#字符串方法和Symbol" class="headerlink" title="字符串方法和Symbol:"></a>字符串方法和Symbol:</h3><ul><li><p><code>startsWith(&quot;&quot;,)</code>从某个下标开始起始字符是不是某个字符</p></li><li><p><code>endsWith(&quot;&quot;,)</code>判断某个下标前一个是不是这个字符</p></li><li><p><code>&quot;&quot;.reprat(3)</code>重复几次</p></li><li><p>判断字符串的长度不足某个值时，在前面补某个字符。</p></li><li><p><code>&quot;&quot;.padStart(3,&quot;&quot;);</code></p></li><li><p><code>&quot;&quot;.padEnd(3,&quot;&quot;);</code></p></li><li><p><code>${变量名}</code></p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">`aa<span class="subst">$&#123;i&#125;</span>aa`</span>;</span><br><span class="line"><span class="keyword">var</span> sre=<span class="string">"aa"</span>+i+<span class="string">"aa"</span>;</span><br></pre></td></tr></table></figure></li><li><h5 id="Symbol-值唯一，不可能重复。"><a href="#Symbol-值唯一，不可能重复。" class="headerlink" title="Symbol:值唯一，不可能重复。"></a>Symbol:值唯一，不可能重复。</h5></li><li><p>用在对象中；对象的Key，只能是字符串或者Symbol类型，如果不是就隐式转换为字符串</p></li><li><h6 id="Symbol-做为Key时，无法通过for-in-遍历；"><a href="#Symbol-做为Key时，无法通过for-in-遍历；" class="headerlink" title="Symbol 做为Key时，无法通过for in 遍历；"></a>Symbol 做为Key时，无法通过for in 遍历；</h6></li></ul><h3 id="Set和Map：："><a href="#Set和Map：：" class="headerlink" title="Set和Map：："></a>Set和Map：：</h3><ul><li><p><strong>数组</strong>：有序的列表，从0开始，可以根据指定的下标找到元素，以及其上下关系的元素，是一种紧密结构，长度会随着添加或者删除而改变；</p><ul><li>作用：主要存储相关类似的数据，便于遍历全部处理。</li><li>缺点：在插入和删除时消耗性能；排序也非常消耗性能。元素没有宿主，元素本身是无关联性的，数组的元素可以重复。查找速度很慢。</li><li>迭代器</li></ul></li><li><p><strong>对象</strong>：无序列表，键值对形式存储。可以通过键找到值，查找速度非常快。</p><ul><li>用来存储关联性数据；因为无序，插入和删除速度非常快。</li><li>缺点：key只能是字符串或者Symbol，无法使用对象或者其他内容作为键；对象是没有长度，无法确定对象是否遍历到最后一个，只能通过键名找到值，无法直接使用值找到键名，需要遍历查找才可以。</li><li>键找值：速度快；值找键：速度慢。</li><li>无迭代器</li></ul></li><li><h5 id="Set"><a href="#Set" class="headerlink" title="Set:"></a>Set:</h5></li><li><p>无序列表，集或者集合，为了解决添加删除查找速度快，将数据以无序的方式存储，自带值去重，无重复列表，有一个维护性的元素数量</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s=<span class="keyword">new</span> <span class="built_in">Set</span>();<span class="comment">//创建</span></span><br><span class="line"><span class="comment">//添加</span></span><br><span class="line">s.add(<span class="number">1</span>);</span><br><span class="line">s.add(<span class="number">2</span>);</span><br><span class="line">s.add(<span class="number">3</span>);</span><br><span class="line">s.delete(<span class="number">2</span>);<span class="comment">//删除</span></span><br><span class="line">s.clear();<span class="comment">//清空</span></span><br><span class="line"><span class="built_in">console</span>.log(s.size)<span class="comment">//长度</span></span><br><span class="line"><span class="built_in">console</span>.log(s.has(<span class="number">2</span>));<span class="comment">//判断有没有某个元素：返回值--false、true</span></span><br></pre></td></tr></table></figure></li><li><p>Set去重：</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr=<span class="built_in">Array</span>.form(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure></li><li><p>具有迭代器的类型使用for…of遍历</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> value <span class="keyword">of</span> s)&#123;</span><br><span class="line">    <span class="built_in">console</span>,log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//集合是没有下标的</span></span><br></pre></td></tr></table></figure></li><li><p><code>forEach</code>：遍历</p></li><li><p><code>WeakSet</code>：弱引用</p></li><li><p>存在WeakSet中的引用对象被设为null，垃圾回收车会自动从列表中清除。不能被遍历</p></li><li><h5 id="Map-类型"><a href="#Map-类型" class="headerlink" title="Map:类型"></a>Map:类型</h5></li><li><p>作用：针对Object做了优化，模仿HashMap，</p></li><li><p>key可以是任何类型，有size–长度。</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">"name"</span>,<span class="string">"值"</span>);<span class="comment">//添加数据</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">map.set(arr,<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li><li><p>判断有没有某个键</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.get(<span class="string">"name"</span>);<span class="comment">//有返回value，没有返回undefined</span></span><br><span class="line">map.has(arr);<span class="comment">//返回true和false。</span></span><br></pre></td></tr></table></figure></li><li><p>删除：按照键名</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.delete(arr);</span><br></pre></td></tr></table></figure></li><li><p>清空</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.clear();</span><br></pre></td></tr></table></figure></li><li><p>遍历键、值</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">map.keys();</span><br><span class="line">map.value();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">of</span> map.keys())&#123;</span><br><span class="line"><span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> [key,value] <span class="keyword">of</span> map)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(key,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> [key,value] <span class="keyword">of</span> map.enties())&#123;</span><br><span class="line"><span class="built_in">console</span>.log(key,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//forEach 完成遍历</span></span><br><span class="line">map.forEach(<span class="function">(<span class="params">value,key</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key,value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>WeakMap：弱引用，键必须是对象</p></li><li><p>不能遍历</p></li></ul><h3 id="生成器函数："><a href="#生成器函数：" class="headerlink" title="生成器函数："></a>生成器函数：</h3><h3 id="类："><a href="#类：" class="headerlink" title="类："></a>类：</h3><ul><li>类–基类–超类–父类–子类–实例化对象–继承</li><li>类别就是实例对象的抽象体现</li><li>实例对象就是类别的具象表现</li><li>子类的父类叫做<strong>超类</strong></li><li>static定义的属性是类自身的属性和方法，实例化的对象不会拥有</li><li>继承：extends</li><li>继承的类需要执行其超类的构造函数—在子类的构造函数中添加 <code>super();</code></li><li>Object 是所有类别的基类</li></ul><h3 id="模块化开发："><a href="#模块化开发：" class="headerlink" title="模块化开发："></a>模块化开发：</h3><ul><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Ball <span class="keyword">from</span> <span class="string">"./js/Ball.js"</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> &#123;A,fn1 <span class="keyword">as</span> fn2,obj&#125; <span class="keyword">from</span> <span class="string">"./js/Other.js"</span>;<span class="comment">// fn1 as fn2 起别名</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>构造函数名统一叫 <code>constructor</code></p></li><li><p>new 类  就是执行该类的constructor函数</p></li><li><p>静态属性、方法中禁止使用this，使用类名调用。</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o=&#123;<span class="attr">c</span>:<span class="number">1</span>,...obj&#125;;<span class="comment">//实现复制obj，浅复制</span></span><br><span class="line">obj,a=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br></pre></td></tr></table></figure></li></ul><h5 id="多选框和单选框"><a href="#多选框和单选框" class="headerlink" title="多选框和单选框"></a>多选框和单选框</h5>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;字符串方法&lt;/li&gt;
&lt;li&gt;Symbol&lt;/li&gt;
&lt;li&gt;Set/Map&lt;/li&gt;
&lt;li&gt;模块化开发&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://ankang.icu/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://ankang.icu/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式与ES6</title>
    <link href="http://ankang.icu/2021/04/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8EES6/"/>
    <id>http://ankang.icu/2021/04/01/正则表达式与ES6/</id>
    <published>2021-04-01T15:06:42.000Z</published>
    <updated>2021-04-01T15:08:37.125Z</updated>
    
    <content type="html"><![CDATA[<ol><li>正则表达式–断言、群组</li><li>ES6–严格模式、箭头函数、解构赋值</li></ol><a id="more"></a><h3 id="正则表达式："><a href="#正则表达式：" class="headerlink" title="正则表达式："></a>正则表达式：</h3><ul><li><p>起始符 <code>^</code></p></li><li><p>结束符 <code>$</code></p></li><li><p>或者 <code>|</code></p></li><li><h5 id="断言："><a href="#断言：" class="headerlink" title="断言："></a>断言：</h5></li><li><p><code>a(?=b)</code>前端断言：判断后面字符是b的a位置</p></li><li><p><code>a(?!b)</code>前端非：</p></li><li><p><code>(?&lt;=d)a</code>后端断言：</p></li><li><p><code>(?&lt;!d)a</code>后端非：</p></li><li><h5 id="群组："><a href="#群组：" class="headerlink" title="群组："></a>群组：</h5></li><li><p>当match不使用g修饰符时，可以将<code>()</code>中内容单独找出来</p></li><li><p><code>$1</code>就是第一个（）内的内容===群组内容</p></li><li><h5 id="中文匹配："><a href="#中文匹配：" class="headerlink" title="中文匹配："></a>中文匹配：</h5></li><li><p>[\4ue00-\u9fd5]{2,4}</p></li></ul><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6:"></a>ES6:</h3><ul><li><p>严格模式 ：</p></li><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.<span class="tag">&lt;<span class="name">script</span> <span class="attr">typr</span>=<span class="string">"module"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">2."use strict";</span><br></pre></td></tr></table></figure></li><li><p>变量必须定义后使用</p></li><li><p>不能出现相同参数名</p></li><li><p>不能使用with语句</p></li><li><p>不能对只读属性赋值</p></li><li><p>不能使用八进制</p></li><li><p>不能删除不可删除的属性</p></li><li><p><code>eval</code>不会在外层作用域引入变量-可以将字符串映射为一个JS对象、变量、属性、函数等</p></li><li><p>不使用参数列表的两个属性</p></li><li><p>不能在顶层使用this</p></li><li><p><code>const</code>/ <code>let</code>：</p></li><li><p><code>let</code>定义全局变量不会放在window属性下</p></li><li><p><code>let</code>定义后不能重复定义，避免变量覆盖</p></li><li><p><code>let</code>定义的变量只能在块语句中生效</p></li><li><h5 id="箭头函数："><a href="#箭头函数：" class="headerlink" title="箭头函数："></a>箭头函数：</h5></li><li><p>是一个匿名函数</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn=<span class="function"><span class="params">a</span>=&gt;</span>a+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//箭头函数中如果参数仅有一个，可以省略（），如果没有参数或者有一个以上都必须加（）；</span></span><br><span class="line"><span class="comment">//在箭头函数中，如果语句块仅有一句，并且这句话使用return返回内容，我们可以去除（）和return关键字。</span></span><br><span class="line"><span class="keyword">var</span> arr1=arr.filter(<span class="function"><span class="params">item</span>=&gt;</span>item&gt;<span class="number">3</span>);</span><br></pre></td></tr></table></figure></li><li><p>箭头函数中的this将会是箭头函数外上下文环境的this指向</p></li><li><p>箭头函数最大特征是改变this的指向为当前箭头函数上下文的this。</p></li><li><p>所有回调函数中this都会被重新指向为window，严格模式除外===&gt;undefined。</p></li><li><h5 id="解构赋值："><a href="#解构赋值：" class="headerlink" title="解构赋值："></a>解构赋值：</h5></li><li><p>变量交换：</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b=<span class="number">4</span>;</span><br><span class="line">[b,a]=[a,b];<span class="comment">//a=4,b=3;</span></span><br><span class="line"><span class="comment">//数组解构按照顺序,可以设置默认值</span></span><br></pre></td></tr></table></figure></li><li><p>对象解构：</p></li><li><p>对象解构是按照key解构；</p></li><li><p>对象中方法解构出来后，成为全局函数，所以对象方法中一旦使用了this，不能解构，解构出来，this的指向发生了改变。===&gt;window。</p></li><li><p>对象解构中如果key名称同名，则可以使用<code>：</code>起别名的方式另外命名。</p></li><li><p>普通函数中传参，有默认值的参数一般写在必填后</p></li><li><p>普通函数中实参的顺序必须和形参的顺序一致。</p></li><li><p>参数赋值时如果整体设置默认值，在调用时如果赋值，默认值将会整体覆盖，不启用。单独设置默认值不会被覆盖。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;正则表达式–断言、群组&lt;/li&gt;
&lt;li&gt;ES6–严格模式、箭头函数、解构赋值&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://ankang.icu/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://ankang.icu/tags/ES6/"/>
    
      <category term="正则表达式" scheme="http://ankang.icu/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>键盘/输入事件与正则表达式概念</title>
    <link href="http://ankang.icu/2021/03/31/%E9%94%AE%E7%9B%98-%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A6%82%E5%BF%B5/"/>
    <id>http://ankang.icu/2021/03/31/键盘-输入事件与正则表达式概念/</id>
    <published>2021-03-31T15:03:36.000Z</published>
    <updated>2021-04-01T15:05:41.335Z</updated>
    
    <content type="html"><![CDATA[<ol><li>KeyboardEvent事件</li><li>InputEvent事件</li><li>滚轮事件</li><li>正则表达式–重复匹配和非贪婪匹配</li></ol><a id="more"></a><h3 id="KeyboardEvent"><a href="#KeyboardEvent" class="headerlink" title="KeyboardEvent:"></a>KeyboardEvent:</h3><ul><li><p>UI组件、document、window都可以侦听此事件</p></li><li><p>keydown：</p></li><li><p>keydoup：</p></li><li><p>keydpress：</p></li><li><h5 id="移动小人："><a href="#移动小人：" class="headerlink" title="移动小人："></a>移动小人：</h5></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打算用setInterval</span></span><br><span class="line"><span class="comment">//e.repeat是否一直按键状态</span></span><br><span class="line"><span class="comment">//利用数组结构解决连续的状态码判断问题</span></span><br><span class="line"><span class="comment">//减少定时器的数量解决问题</span></span><br></pre></td></tr></table></figure></li><li><h5 id="防抖：某一段时间内只执行一次"><a href="#防抖：某一段时间内只执行一次" class="headerlink" title="防抖：某一段时间内只执行一次"></a>防抖：某一段时间内只执行一次</h5></li><li><p>keyCode/which：键码</p></li><li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">键盘按键：leftuprightdown:37-40</span><br></pre></td></tr></table></figure></li></ul><h3 id="InputEvent："><a href="#InputEvent：" class="headerlink" title="InputEvent："></a>InputEvent：</h3><ul><li><p>针对表单元素单独做失焦和聚焦处理</p><ul><li>focus：聚焦</li><li>blur：失焦</li></ul></li><li><p>针对表单所有元素的失焦和聚焦</p><ul><li>focusin</li><li>focusout</li></ul></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//e.relatedTarget</span></span><br><span class="line"><span class="comment">//上一个或者下一个目标对象，失焦就是下一个聚焦对象，聚焦就是上一个失焦对象</span></span><br></pre></td></tr></table></figure></li><li><p>超链接和所有表单元素都是可以做聚焦与失焦事件</p></li><li><h5 id="input事件："><a href="#input事件：" class="headerlink" title="input事件："></a>input事件：</h5><ul><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isComposing:<span class="literal">true</span><span class="comment">//判断是否使用输入法</span></span><br><span class="line">data a<span class="comment">//当前输入的数据</span></span><br><span class="line">inputType:<span class="string">"insertText"</span><span class="comment">//当前输入状态</span></span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="节流：间隔时间执行"><a href="#节流：间隔时间执行" class="headerlink" title="节流：间隔时间执行"></a>节流：间隔时间执行</h5></li></ul><h3 id="滚轮事件："><a href="#滚轮事件：" class="headerlink" title="滚轮事件："></a>滚轮事件：</h3><ul><li><p>兼容事件、继承鼠标事件</p></li><li><p>mousewheel：火狐不支持</p></li><li><p>DOMMouseScroll：</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deltaX:</span><br><span class="line">deltaY:<span class="number">-100</span>;向上</span><br><span class="line">wheelDelatY:<span class="number">100</span>;向上</span><br></pre></td></tr></table></figure></li><li><p>兼容写法：</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"mousewheel"</span>,mouseHandler);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"DOMMouseScroll"</span>,mouseHandler);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mouseHandler</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> detail;</span><br><span class="line">    <span class="keyword">if</span>(e.type===<span class="string">"mousewheel"</span>)&#123;</span><br><span class="line">        detail=e.deltaY&lt;<span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e.type===<span class="string">"DOMMouseScroll"</span>)&#123;</span><br><span class="line">        detail=e.detail&lt;<span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//console.log(e);</span></span><br><span class="line">    <span class="comment">//console.log(detail);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="自定义滚动条："><a href="#自定义滚动条：" class="headerlink" title="自定义滚动条："></a>自定义滚动条：</h5></li></ul><h3 id="正则表达式："><a href="#正则表达式：" class="headerlink" title="正则表达式："></a>正则表达式：</h3><ul><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/^(?=\D+\d)(?=.*[a-z])(?=/</span>[A-Z])[<span class="number">0</span><span class="number">-9</span>a-zA-Z]&#123;<span class="number">8</span>,<span class="number">16</span>&#125;$/</span><br></pre></td></tr></table></figure></li><li><p>字面量定义</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/a/i</span>;</span><br></pre></td></tr></table></figure></li><li><p>构造函数定义</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"正则内容"</span>,<span class="string">"修饰符"</span>);</span><br><span class="line"><span class="keyword">var</span> reg=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"a"</span>,<span class="string">"i"</span>);</span><br></pre></td></tr></table></figure></li><li><p>正则内容：目的–匹配字符串中的内容，或者查找字符串中的内容</p></li><li><p>修饰符：</p><ul><li>i：不区分大小写</li><li>m：多行</li><li>g：全局查找</li></ul></li><li><p>正则对象的方法：</p><ul><li><code>reg.test();</code>//判断字符串是否满足正则条件</li><li><code>reg.exec();</code>//根据正则在字符串中查找到对应的元素，并且挡在数组中，有下标index属性和群组groups属性，一般<code>g</code>无效</li></ul></li><li><p>字符串对象可以使用正则方法：</p><ul><li><p>str.replace();//替换</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[];</span><br><span class="line">str.replace(<span class="regexp">/e/g</span>,<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    arr.push(b);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"18617805540"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.replace(<span class="regexp">/^(\d&#123;3&#125;)\d&#123;4&#125;(\d&#123;4&#125;)$/</span>,<span class="string">"$1****$2"</span>))</span><br></pre></td></tr></table></figure></li><li><p>str.search();//查找，返回下标，对 <code>g</code>无效</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.search(<span class="regexp">/a(?=b)/g</span>)<span class="comment">//查找a后面为b的位置。</span></span><br></pre></td></tr></table></figure></li><li><p>str.split();//切割</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.split(<span class="regexp">/[bcd]/</span>)<span class="comment">//可以多个字符切割</span></span><br><span class="line"><span class="string">"config.jpg"</span>.split(<span class="regexp">/(?=\.)/</span>)<span class="comment">//["config", ".jpg"]</span></span><br></pre></td></tr></table></figure></li><li><p>str.match();//匹配，所有匹配正则表达式的内容放在一个数组中。</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"2[bc]3[de]"</span>;</span><br><span class="line"><span class="keyword">var</span> arr=str.match(<span class="regexp">/(\d)\[(\w+)\]/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>.</code>通配符：代表任意一个字符,在 <code>[]</code>中会自动转为字符 <code>.</code>，使用 <code>\.</code>也是字符 <code>.</code></p></li><li><p><code>\</code>转移字符：转译为字符串。本身在字符串中就有转义的含义</p></li><li><p><code>[]</code>可能代表一个字符的列表，可以使用里面的任意一个字符</p><p>只能表示一个字符</p></li><li><p><code>[^abcd]</code>在正则中括号内的第一个字符使用^开始，表示后续的内容取反</p><p><code>[a^c]</code>当^不是中括号中的第一位则表示字符^。</p></li><li><p><code>\w</code>===[a-zA-Z0-9_]</p></li><li><p><code>\W</code>===<code>[^a-zA-Z0-9_]</code></p></li><li><blockquote><p>\d===[0-9]</p><p>\D===[ ^0-9]</p><p>\s===空白字符  空格</p><p>\S===非空白字符//字符与字符之间有空字符</p></blockquote></li></ul><h3 id="重复匹配和非贪婪匹配："><a href="#重复匹配和非贪婪匹配：" class="headerlink" title="重复匹配和非贪婪匹配："></a>重复匹配和非贪婪匹配：</h3><ul><li><code>{}</code>表示重复次数：<ul><li><code>{0，1}</code>=== <code>?</code></li><li><code>{1,}</code>=== <code>+</code></li><li><code>{0,}</code>=== <code>*</code></li></ul></li><li><code>()\1</code> ：括号内最大重复次数  分类取出重复的最大次数</li><li>非贪婪匹配：前后会有其他内容约束范围，<ul><li><code>.*?</code></li><li><code>\b</code>单词分隔符</li><li><code>\B</code>非单词分隔符</li></ul></li></ul><h3 id="网易地址截取"><a href="#网易地址截取" class="headerlink" title="网易地址截取"></a>网易地址截取</h3>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;KeyboardEvent事件&lt;/li&gt;
&lt;li&gt;InputEvent事件&lt;/li&gt;
&lt;li&gt;滚轮事件&lt;/li&gt;
&lt;li&gt;正则表达式–重复匹配和非贪婪匹配&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://ankang.icu/tags/JavaScript/"/>
    
      <category term="事件" scheme="http://ankang.icu/tags/%E4%BA%8B%E4%BB%B6/"/>
    
      <category term="正则表达式" scheme="http://ankang.icu/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>系统事件概念</title>
    <link href="http://ankang.icu/2021/03/30/%E7%B3%BB%E7%BB%9F%E4%BA%8B%E4%BB%B6%E6%A6%82%E5%BF%B5/"/>
    <id>http://ankang.icu/2021/03/30/系统事件概念/</id>
    <published>2021-03-30T14:35:55.000Z</published>
    <updated>2021-03-30T14:38:22.268Z</updated>
    
    <content type="html"><![CDATA[<ol><li>系统事件-Event对象、MouseEvent对象</li><li>图片预加载</li><li>拖拽</li></ol><a id="more"></a><h3 id="事件的区别："><a href="#事件的区别：" class="headerlink" title="事件的区别："></a>事件的区别：</h3><ul><li><p>事件写法的不同：</p><ul><li><p>在标签中写只能添加一个onclick事件函数，早期的事件会自动设置一个event全局变量，用于事件的处理，同步执行时不会丢失，异步执行延迟会消除。无冒泡。</p></li><li><p>DOM对象添加方法，不再使用全局变量e，只能执行一个函数。有冒泡功能，没有捕获功能。不支持自定义事件这样写大多数都会写出匿名函数。大多数的回调地狱都是在事件函数中发生的，原因是匿名函数的使用。</p><blockquote><p>e=e || window.event;</p><p>bn.onclick=null;//清除事件</p></blockquote></li><li><p>侦听事件类型：一般这种事件不写匿名函数，写命名函数，适合于函数式编程。这种事件包括捕获。冒泡阶段和阻止，还包括自带事件event对象，设置是否执行一次，支持自定义事件，IE8及以下不支持。onclick等所有系统事件===&gt;去掉on。可以执行多个函数</p><blockquote><p>bn.removeEventListener(“事件”,函数名)//删除事件</p></blockquote></li><li><p>IE11以下支持，IE11及以上不支持，没有捕获阶段触发</p><blockquote><p>bn.attachEvent(“on事件”,函数名);</p><p>bn.detachEvent(“on事件”,函数名);</p></blockquote></li></ul></li></ul><h3 id="Event对象："><a href="#Event对象：" class="headerlink" title="Event对象："></a>Event对象：</h3><ul><li><p>表单应用事件：</p></li><li><p>submit和reset</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">from</span>=<span class="built_in">document</span>.querySelector(<span class="string">"form"</span>);</span><br><span class="line">form.addEventListener(<span class="string">"submit"</span>,submitHanlder);</span><br><span class="line">form.addEventListener(<span class="string">"reset"</span>,submitHanlder);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">submitHanlder</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//阻止表单跳转 submit</span></span><br><span class="line">    <span class="comment">//阻止表单重置 reset</span></span><br><span class="line">    e.preventDefault()  阻止默认事件行为</span><br><span class="line">    e.returnValue=<span class="literal">false</span>  返回值=<span class="literal">false</span><span class="comment">//兼容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>select：针对input或者textArea的</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//input.selecttionStart//输入框中的选中开始位置下标</span></span><br><span class="line"><span class="comment">//input.selecttionEnd//输入框中的选中结束位置下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> input=<span class="built_in">document</span>.querySelector(<span class="string">"input"</span>);</span><br><span class="line">input.addEventListener(<span class="string">"select"</span>,selectHandler);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectHandler</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">    <span class="comment">// console.log(input.selectionStart,input.selectionEnd)</span></span><br><span class="line">    input.value=input.value.slice(<span class="number">0</span>,input.selectionStart)+</span><br><span class="line">    input.value.slice(input.selectionStart,input.selectionEnd).toUpperCase()</span><br><span class="line">    +input.value.slice(input.selectionEnd)</span><br><span class="line">    <span class="comment">//将文本输入框中的选中单词变成大写。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>change：可以针对表单元素,也可以针对form表单</p></li><li><p>失去焦点时，原value的值发生改变时，触发</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对表单时，判断整个表单的修改</span></span><br><span class="line"><span class="keyword">var</span> form=<span class="built_in">document</span>.querySelector(<span class="string">"form"</span>);</span><br><span class="line">form.addEventListener(<span class="string">"change"</span>,changeHandler);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeHandler</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target,e.target.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>resize  更改浏览器中文档大小 –只针对window侦听</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//em就是父容器的字体大小</span></span><br><span class="line"><span class="comment">//rem相对于根标签的字体大小（html）</span></span><br><span class="line">resizeHandler();</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>,resizeHandler);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizeHandler</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// console.log(screen.width)</span></span><br><span class="line">    <span class="built_in">document</span>.documentElement.style.fontSize=<span class="built_in">document</span>.body.clientWidth/screen.width*<span class="number">100</span>+<span class="string">"px"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>图片的加载需要时间，无法立即获得宽度 <code>offsetWidth</code></p></li><li><p>预加载 <code>load</code>加载完成，滞后性极强</p></li><li><p>图片加载不适用load事件，所以：</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img=<span class="keyword">new</span> Image();</span><br><span class="line">img.addEventListener();</span><br><span class="line">img.src=<span class="string">"地址"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img1=img.cloneNode(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(img1);</span><br><span class="line"><span class="built_in">console</span>.log(img.width);<span class="comment">//原图的宽高</span></span><br><span class="line">    img1.style.width=<span class="string">"600px"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(img.width);</span><br><span class="line">    <span class="comment">//克隆一个图片副本，修改宽高放进容器中，原始图宽高不变。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="图片预加载的几种方式比较及改善"><a href="#图片预加载的几种方式比较及改善" class="headerlink" title="图片预加载的几种方式比较及改善"></a><em>图片预加载</em>的几种方式比较及改善</h5></li><li><p>scroll：滚动条，默认自动阻止冒泡，通过事件属性传递值。</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">div1.addEventListener(<span class="string">"scroll"</span>,scrollHandler);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"scroll"</span>,scrollHandler1);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollHandler</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">    <span class="comment">//var evt=new Event("scroll");</span></span><br><span class="line">    <span class="comment">//evt.scrollTop=this.scrollTop;</span></span><br><span class="line">    <span class="comment">//window.dispatchEvent(evt);//自建事件在触发子元素的滚动事件时抛发，来达到传递数据的效果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollHandler1</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.documentElement.scrollTop=e.scrollTop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>error：加载失败时，触发错误事件。</p></li></ul><h3 id="MouseEvent对象："><a href="#MouseEvent对象：" class="headerlink" title="MouseEvent对象："></a>MouseEvent对象：</h3><ul><li><p>按住键盘辅助键点击</p><ul><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctrlKey</span><br><span class="line">altKey</span><br><span class="line">shiftKey</span><br><span class="line">metaKey</span><br></pre></td></tr></table></figure></li></ul></li><li><p>判断鼠标按键</p><ul><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button<span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line">buttons<span class="number">1</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line">which<span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>坐标</p><ul><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">x:</span><br><span class="line">y:</span><br><span class="line">clientX:</span><br><span class="line">clientY:</span><br><span class="line"><span class="comment">//鼠标相对视口距离</span></span><br><span class="line">pageX:</span><br><span class="line">pageY:</span><br><span class="line"><span class="comment">//相对页面顶端位置/绝对坐标位置</span></span><br><span class="line">layerX:</span><br><span class="line">layerY:</span><br><span class="line"><span class="comment">//相对e.target左上角的坐标，如果目标元素定位了，和offset值相同；如果没有定位，offset不变，layer相对父元素的左上角位置。</span></span><br><span class="line">offsetX:</span><br><span class="line">offsetY:</span><br><span class="line"><span class="comment">//相对e.target左上角的坐标</span></span><br><span class="line">movementX:</span><br><span class="line">movementY:</span><br><span class="line"><span class="comment">//用于Mousemove事件，相对于上次移动距离。==汽车图片</span></span><br><span class="line">screenX:</span><br><span class="line">screenY:</span><br><span class="line"><span class="comment">//绝对于屏幕左上角</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>鼠标事件：</p><ul><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">click</span><br><span class="line">dbclick</span><br><span class="line">mousedown</span><br><span class="line">mouseup</span><br><span class="line">mousemove</span><br><span class="line"></span><br><span class="line">mouseover</span><br><span class="line">mousenter</span><br><span class="line">mouseout</span><br><span class="line">mouseleave</span><br><span class="line"><span class="comment">//mousenter和mouseleave不会因为进入子元素而抛发事件</span></span><br><span class="line"><span class="comment">//mouseover和mouseout会因为子元素而抛发事件</span></span><br><span class="line">contextmenu</span><br><span class="line"><span class="comment">//如果是contextmenu，会呼出右键菜单</span></span><br><span class="line"><span class="comment">//e.preventDefault()阻止呼出菜单</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h3>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;系统事件-Event对象、MouseEvent对象&lt;/li&gt;
&lt;li&gt;图片预加载&lt;/li&gt;
&lt;li&gt;拖拽&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://ankang.icu/tags/JavaScript/"/>
    
      <category term="事件" scheme="http://ankang.icu/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
</feed>
